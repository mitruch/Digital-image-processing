\documentclass[final,a4paper,openany,12pt]{mwbk}
%\documentclass[final,a4paper,openright,12pt]{mwbk} % każdy rozdział zaczyna się na stronie nieparzystej
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{url}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumerate}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{titlesec}
\usepackage{amsmath}
\usepackage{listings}
\lstset{
language=Python,
breaklines=true,
tabsize=2,
breaklines  = true,
breakatwhitespace   = false,
prebreak= \space,
postbreak   = \space  
}   



\titleformat{\section}[runin]
{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}[runin]
{\normalfont\large\bfseries}{\thesubsection}{1em}{}




\usepackage{makeidx}  % allows index generation
\usepackage{graphicx} % standard LaTeX graphics tool
                      % for including eps-figure files
\graphicspath{{img/}{img/Zegarek}}
\usepackage{float}


%\prefixing %polskie znaki: /a /c /e /z /x /o /s /l /A /C itd. %ZAKOMENTOWANE BO SIE NIE DA UZYWAC "/"

\renewcommand*\listalgorithmname{Spis algorytmów\protect} % łatka na niedoróbkę w spisie algorytmów - nie usuwać!

% zestaw przydatny, kiedy trzeba regulować szerokość kolumn w tablicy:
%%\usepackage{longtable}
%\usepackage{array}
%\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
%\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
%\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\newtheorem{twr}{Twierdzenie}[section]

% ustawienia do wydruku dwustronnego z uwzględnieniem dodatkowego miejsca na zszycie
\setlength{\oddsidemargin}{0.46cm}   %margines nieparzysty
\setlength{\evensidemargin}{-0.54cm} %margines parzysty
\setlength{\textwidth}{16cm}         %szerokość tekstu na stronie
\linespread{1.1}    % lekkie zwiększenie odstępu między liniami, żeby tekst nie był taki ścisły, ponieważ
                    % Odstęp pojedynczej interlinii nie jest komfortowy, kiedy trzeba czytać strony A4
% koniec ustawień

%\makeindex            % used for the subject index
                      % please use the style sprmidx.sty with
                      % your makeindex program
\begin{document}

\begin{titlepage}
\vspace{-0.5cm}

{\centering
{\footnotesize
\begin{tabular}{c}
UNIWERSYTET KARDYNAŁA STEFANA WYSZYŃSKIEGO\\
W WARSZAWIE\\
\end{tabular}
}
\vspace{2.5cm}

{\footnotesize
\begin{tabular}{c}
WYDZIAŁ MATEMATYCZNO-PRZYRODNICZY\\
SZKOŁA NAUK ŚCISŁYCH\\
\end{tabular}
}
\vspace{2.5cm}

\renewcommand{\arraystretch}{1.5} % zwiększamy odległość między wierszami

{\normalsize
\begin{tabular}{c}
Katarzyna Mitrus\\
Michał Słotwiński\\
\end{tabular}
}

\vspace{1.5cm}

{\large
\begin{tabular}{c}

Wprowadzenie do Przetwarzania Obrazów\\
Sprawozdanie z laboratorium\\

\end{tabular}
}

}

\renewcommand{\arraystretch}{1} % przywracamy domyślną odległość miedzy wierszami

\vspace{5cm}

\hspace{6cm}
\begin{tabular}{l}
Prowadzący:\\
prof. Wojciech Mokrzycki\\

\end{tabular}

\vspace{4cm}

{\centering

{\small
\begin{tabular}{c}
{Warszawa, 2018}\\
\end{tabular}
}

}
\end{titlepage}

\tableofcontents
\listoffigures
%\listoftables
%\listofalgorithms

\sloppy


%Laboratoria ~\cite{BookMok} %przynajmniej jedna cytacja dla kompilatora LATEX

\chapter{Wstęp}

\section {Specyfikacja wykorzystanego fortmatu obrazu}
\textbf{Tagged Imange File Format} (\textbf{TIFF} or \textbf{TIF}) jest formatem pliku komputerowego do przechowywania obrazów grafiki rastrowej(oraz osadzania elementów grafiki wektorowej). Jest rastrowym formatem uniwersalnym, tzn. może być zapisany w trybie kolorów:
\begin{itemize}
	\item CMYK
	\item YCbCr
	\item CIELab
	\item RGB
	\item skala szarości
	\item kolor opary na indeksowaniu
	\item kolor oparty na bitmapie z dowolną głębokością bitową
\end{itemize}
Również można dobrać dowolną rozdzielczość z opcją kanału przezroczystości alfa lub bez.
Format TIFF wiele algorytmów kompresji bezstratnej:
\begin{itemize}
	\item PackBits
	\item LZW (Lempel-Ziv-Welch)
	\item CCITT Fax group 3 \& 4
\end{itemize}
Plik TIFF podzielony jest na trzy części:
\begin{enumerate}
	\item nagłówek pliku obrazowego ( Image File Header, IFH)
	\item katalog pliku obrazowego (Image File Directory, IFD)
	\item część danych obrazu
\end{enumerate}
Plik TIFF może zawierać wiele obrazów. Nagłówek pliku składa się
z ośmiu bajtów. Jak sama nazwa wskazuje, format TIFF używa struktur danych noszących nazwę Tag, definiujących cechy zawartych w nim obrazów. Np. dla obrazu 320x240 piksli, szerokość była by oznaczona tag'iem "width", a wysokość "height", po którym następuje liczba 320 lub 240.
Poniżej znajdują się trzy możliwe formy wewnętrznej struktury danych pliku TIFF(zawierającej trzy obrazy).
\begin{center}
	\begin{tabular}{|c|c|c|}
		\hline
		header & header & header\\
		\hline
		IFD 0 & IFD 0 & Image 0\\
		\hline
		IFD 1 & Image 0 & Image 1\\
		\hline
		IFD n & IFD 1 & Image 2\\
		\hline
		Image 0 & Image 1 & IFD 0\\
		\hline
		Image 1 & IFD 2 & IFD 1\\
		\hline
		Image n & Image 2 & IFD 2\\
		\hline
	\end{tabular}
\end{center}
W każdym przykładzie nagłówek pojawia się na początku.
W pierwszym przykładzie katalog(IFD) jest zapisany na początku jeden za drugim, taki sposób pozwala na szybki odczyt danych.\\
W drugim przykładzie po każdym katalogu(IFD) są dane bitmapowe, co jest najczęściej spotykanym rozowiązaniem przy plikach z wieloma obrazami.\\
W ostatnim przykładzie najpierw są zapisane dane bitmapowe, a następnie katalogi(IFD).\\
Aby sprawdzić, czy obraz jest zapisany w formacie TIFF wystarczy odczytać z nagłówka pierwsze 4 bajty, jeśli mają wartość 49h 49h 00h 2Ah lub 4Dh 4Dh 00h 2Ah, to jest to plik TIFF.

\section {Intstrukcja obsługi programu}
\hfill\\
\\\\
\indent
Implementacja zadań została napisana w języku Python3. Wykorzystane biblioteki to numpy, matplotlib oraz
Pillow. Aby wystartować program i rozpocząć otrzymywanie wyników przetwarzania pozczególnych obrazów należy uruchomić plik main.py
Przykład uruchomienia programu:\\
$python$ main.py


\chapter{Operacje ujednolicania obrazów}
Operacja ujednolicania obrazów dzieli się na dwa etapy. Pierwszym jest ujednolicenie geometryczne, drugim zaś ujednolicenie rozdzielczościowe. W tym programie ujednolicane są dwa obrazy rastrowe w taki sopsób, że mniejszy doprowadzany jest do większego, przez co generowany jest nowy obraz o większe liczbie piksli niż początkowo. Taki sposób ujednolicania nie powoduje widocznego spadku jakości.
\newpage

\section{Ujednolicenie obrazów szarych geometryczne}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Operacja geometrycznego ujednolicenia obrazów polega na doprowadzeniu obydwu obrazów do takiej samej liczby wierszy piksli w każdym obrazie i takiej samej liczby kolumn piksli w każdym obrazie.
\begin{enumerate}
	\item Wybierz największą wysokość i największą szerokość z dwuch obrazów.\\
	\item Jeśli dany obraz ma mniejszą szerokość albo wysokość, wypełnij różnicę pikslami o wartości 1 (aby uniknąć dzielenia przez 0).
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{gentelman_gray}
		\includegraphics[width=0.4\textwidth]{pirate_gray}
	\end{center}
	\caption{Obrazy wejściowe (od lewej): obraz 1 (256x256), obraz 2 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{gentelman_gray_unificationGeo_result}
		\includegraphics[width=0.4\textwidth]{pirate_gray_unificationGeo_result}
	\end{center}
	\caption{Obrazy wyjściowe (od lewej): obraz 1 (512x512), obraz 2 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{clock_gray}
		\includegraphics[width=0.4\textwidth]{boat_gray}
	\end{center}
	\caption{Obrazy wejściowe (od lewej): obraz 3 (256x256), obraz 4 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{clock_gray_unificationGeo_result}
		\includegraphics[width=0.4\textwidth]{boat_gray_unificationGeo_result}
	\end{center}
	\caption{Obrazy wyjściowe (od lewej): obraz 3 (512x512), obraz 4 (512x512)}
\end{figure}

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Geometryczne ujednolicanie obrazów szarych]

def geometricGray(self, show = False):
	# najwieksza szerokosc sposrod dwuch obrazow
	width1 = self.im1.shape[1]
	width2 = self.im2.shape[1]
	maxWidth = width1 if width1 > width2 else width2

	# najwieksza wysokosc sposrod dwuch obrazow
	height1 = self.im1.shape[0]
	height2 = self.im2.shape[0]
	maxHeight = height1 if height1 > height2 else height2

	# alokacja pamieci na obrazy wynikowe
	resultImage1 = np.empty((maxHeight, maxWidth), dtype = np.uint8)
	resultImage2 = np.empty((maxHeight, maxWidth), dtype = np.uint8)

	# wspolrzedne poczatku rysowania obrazu 1 w srodku
	startWidthCoord = int(round((maxWidth - width1) / 2))
	startHeightCoord = int(round((maxHeight - height1) / 2))

	# wypelnienie obrazu czarny kolorem
	for i in range(0, maxHeight):
		for j in range(0, maxWidth):
			resultImage1[i, j] = 1

	# narysowanie wysrodkowanego obrazu
	for i in range(0, height1):
		for j in range(0, width1):
			resultImage1[i + startHeightCoord, j + startWidthCoord] = self.im1[i, j]

	# wspolrzedne poczatku rysowania obrazu 1 w srodku
	startWidthCoord = int(round((maxWidth - width2) / 2))
	startHeightCoord = int(round((maxHeight - height2) / 2))

	# wypelnienie obrazu czarnym kolorem
	for i in range(0, maxHeight):
		for j in range(0, maxWidth):
			resultImage2[i, j] = 1

	# narysowanie wysrodkowanego obrazu
	for i in range(0, height2):
		for j in range(0, width2):
			resultImage2[i + startHeightCoord, j + startWidthCoord] = self.im2[i, j]

	if show:
		self.show(Image.fromarray(resultImage1, "L"), Image.fromarray(resultImage2, "L"))
	self.save(resultImage1, self.im1Name, "unificationGeo")
	self.save(resultImage2, self.im2Name, "unificationGeo")

\end{lstlisting}


\newpage





\section{Ujednolicenie obrazów szarych rozdzielczościowe}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Operacja rozdzielczościowego ujednolicenia obrazów następuje po ujednoliceniu geometrycznym i polega na wypełnieniu obrazu pikslami, a brakujące piksle powinny być zinterpolowane.

\begin{enumerate}
	\item Wypełnij cały obraz pikslami o znanej wartości zachowując pewien odstęp między nimi, gdzie odstępem będą piksle o wartości 0.
	\item Każdemu pikslowi o nieznanej wartości przypisz średnią wartość znanych ($> 0$) piksli z jego bezpośredniego otoczenia.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_unificationGeo_result}
		\includegraphics[width=0.35\textwidth]{pirate_gray_unificationGeo_result}
	\end{center}
	\caption{Obrazy wejściowe (od lewej): obraz 1 (512x512), obraz 2 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_unificationRas_result}
		\includegraphics[width=0.35\textwidth]{pirate_gray_unificationRas_result}
	\end{center}
	\caption{Obrazy wyjściowe (od lewej): obraz 1 (512x512), obraz 2 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{clock_gray_unificationGeo_result}
		\includegraphics[width=0.35\textwidth]{boat_gray_unificationGeo_result}
	\end{center}
	\caption{Obrazy wejściowe (od lewej): obraz 3 (512x512), obraz 4 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{clock_gray_unificationRas_result}
		\includegraphics[width=0.35\textwidth]{boat_gray_unificationRas_result}
	\end{center}
	\caption{Obrazy wyjściowe (od lewej): obraz 3 (512x512), obraz 4 (512x512)}
\end{figure}

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Rastrowe ujednolicanie obrazów szarych]

def rasterGray(self, show = False):
	# pierwszy jest ZAWSZE wiekszy
	width1 = self.im1.shape[1]
	width2 = self.im2.shape[1]
	
	height1 = self.im1.shape[0]
	height2 = self.im2.shape[0]
	
	scaleW = width1 / width2
	scaleH = height1 / height2
	
	# alokacja pamieci na obrazy wynikowe
	resultImage1 = np.zeros((height1, width1), dtype = np.uint8)
	resultImage2 = np.zeros((height1, width1), dtype = np.uint8)
	tmp = np.zeros((height1, width1), dtype = np.uint8)
	
	for i in range(height1):
		for j in range(width1):
			resultImage1[i, j] = self.im1[i, j]
	
	# wypelnianie
	count = 0
	for i in range(height2):
		for j in range(width2):
			if count == 0:
				resultImage2[int(scaleH*i), int(round(scaleW*j)) + 1] = self.im2[i, j]
				count += 1
			if count == 1:
				resultImage2[int(round(scaleH*i)) + 1, int(scaleW*j)] = self.im2[i, j]
				count = 0
	
	# interpolacja
	for i in range(height1):
		for j in range(width1):
			value = 0
			n = 0
			tmp[i, j] = resultImage2[i, j]
			if resultImage2[i, j] < 1:
				for iOff in range(-1, 2):
					for jOff in range(-1, 2):
						iSafe = i if ((i + iOff) > (height1 - 2)) | ((i + iOff) < 0) else (i + iOff)
						jSafe = j if ((j + jOff) > (width1 - 2)) | ((j + jOff) < 0) else (j + jOff)
						if resultImage2[iSafe, jSafe] > 0:
							value += resultImage2[iSafe, jSafe]
							n += 1
				tmp[i, j] = value / n
				resultImage2[i, j] = tmp[i, j]
	
	if show:
		self.show(Image.fromarray(resultImage1, "L"), Image.fromarray(resultImage2, "L"))
	self.save(resultImage1, self.im1Name, "unificationRas")
	self.save(resultImage2, self.im2Name, "unificationRas")

\end{lstlisting}

\newpage







\section{Ujednolicenie obrazów RGB geometryczne}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Operacja geometrycznego ujednolicenia obrazów polega na doprowadzeniu obydwu obrazów do takiej samej liczby wierszy piksli w każdym obrazie i takiej samej liczby kolumn piksli w każdym obrazie.

\begin{enumerate}
	\item Wybierz największą wysokość i największą szerokość z dwuch obrazów.
	\item Jeśli dany obraz ma mniejszą szerokość albo wysokość, wypełnij różnicę pikslami o wartości 1 dla każdego z kanałów R, G i B (aby uniknąć dzielenia przez 0).
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{lena_color}
		\includegraphics[width=0.4\textwidth]{peppers_color}
	\end{center}
	\caption{Obrazy wejściowe (od lewej): obraz 1 (256x256), obraz 2 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{lena_color_unificationGeo_result}
		\includegraphics[width=0.4\textwidth]{peppers_color_unificationGeo_result}
	\end{center}
	\caption{Obrazy wyjściowe (od lewej): obraz 1 (512x512), obraz 2 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{candy_color}
		\includegraphics[width=0.4\textwidth]{mandrill_color}
	\end{center}
	\caption{Obrazy wejściowe (od lewej): obraz 3 (256x256), obraz 4 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{candy_color_unificationGeo_result}
		\includegraphics[width=0.4\textwidth]{mandrill_color_unificationGeo_result}
	\end{center}
	\caption{Obrazy wyjściowe (od lewej): obraz 3 (512x512), obraz 4 (512x512)}
\end{figure}

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Geometryczne ujednolicanie obrazów barwnych]

def geometricColor(self, show = False):
	# najwieksza szerokosc sposrod dwuch obrazow
	width1 = self.im1.shape[1]
	width2 = self.im2.shape[1]
	maxWidth = width1 if width1 > width2 else width2
	
	# najwieksza wysokosc sposrod dwuch obrazow
	height1 = self.im1.shape[0]
	height2 = self.im2.shape[0]
	maxHeight = height1 if height1 > height2 else height2
	
	# alokacja pamieci na obrazy wynikowe
	resultImage1 = np.empty((maxHeight, maxWidth, 3), dtype = np.uint8)
	resultImage2 = np.empty((maxHeight, maxWidth, 3), dtype = np.uint8)
	
	# wspolrzedne poczatku rysowania obrazu 1 w srodku
	startWidthCoord = int(round((maxWidth - width1) / 2))
	startHeightCoord = int(round((maxHeight - height1) / 2))
	
	# wypelnienie obrazu czarnym kolorem
	for i in range(0, maxHeight):
		for j in range(0, maxWidth):
			resultImage1[i, j] = (1, 1, 1)
	
	# narysowanie wysrodkowanego obrazu
	for i in range(0, height1):
		for j in range(0, width1):
			resultImage1[i + startHeightCoord, j + startWidthCoord] = self.im1[i, j]
	
	# wspolrzedne poczatku rysowania obrazu 1 w srodku
	startWidthCoord = int(round((maxWidth - width2) / 2))
	startHeightCoord = int(round((maxHeight - height2) / 2))
	
	# wypelnienie obrazu czarnym kolorem
	for i in range(0, maxHeight):
		for j in range(0, maxWidth):
			resultImage2[i, j] = (1, 1, 1)

	# narysowanie wysrodkowanego obrazu
	for i in range(0, height2):
		for j in range(0, width2):
			resultImage2[i + startHeightCoord, j + startWidthCoord] = self.im2[i, j]
	
	if show:
		self.show(Image.fromarray(resultImage1, "RGB"), Image.fromarray(resultImage2, "RGB"))
	self.save(resultImage1, self.im1Name, "unificationGeo")
	self.save(resultImage2, self.im2Name, "unificationGeo")
\end{lstlisting}

\newpage





\section{Ujednolicenie obrazów RGB rozdzielczościowe}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Operacja rozdzielczościowego ujednolicenia obrazów następuje po ujednoliceniu geometrycznym i polega na wypełnieniu obrazu pikslami, a brakujące piksle powinny być zinterpolowane.

\begin{enumerate}
	\item Wypełnij cały obraz pikslami o znanej wartości zachowując pewien odstęp między nimi.
	\item Każdemu pikslowi o nieznanej wartości przypisz zinterpolowaną wartość (dla każdego z kanałów R, G, B) znanych piksli z jego bezpośredniego otoczenia.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{lena_color_unificationGeo_result}
		\includegraphics[width=0.4\textwidth]{peppers_color_unificationGeo_result}
	\end{center}
	\caption{Obrazy wejściowe (od lewej): obraz 1 (512x512), obraz 2 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{lena_color_unificationRas_result}
		\includegraphics[width=0.4\textwidth]{peppers_color_unificationRas_result}
	\end{center}
	\caption{Obrazy wyjściowe (od lewej): obraz 1 (512x512), obraz 2 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{candy_color_unificationGeo_result}
		\includegraphics[width=0.4\textwidth]{mandrill_color_unificationGeo_result}
	\end{center}
	\caption{Obrazy wejściowe (od lewej): obraz 3 (512x512), obraz 4 (512x512)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{candy_color_unificationRas_result}
		\includegraphics[width=0.4\textwidth]{mandrill_color_unificationRas_result}
	\end{center}
	\caption{Obrazy wyjściowe (od lewej): obraz 3 (512x512), obraz 4 (512x512)}
\end{figure}

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Rastrowe ujednolicanie obrazów barwnych]

def rasterColor(self, show = False):
	# pierwszy jest ZAWSZE wiekszy
	width1 = self.im1.shape[1]
	width2 = self.im2.shape[1]
	
	height1 = self.im1.shape[0]
	height2 = self.im2.shape[0]
	
	scaleW = width1 / width2
	scaleH = height1 / height2
	
	# alokacja pamieci na obrazy wynikowe
	resultImage1 = np.zeros((height1, width1, 3), dtype = np.uint8)
	resultImage2 = np.zeros((height1, width1, 3), dtype = np.uint8)
	tmp = np.zeros((height1, width1, 3), dtype = np.uint8)
	
	for i in range(height1):
		for j in range(width1):
			resultImage1[i, j] = self.im1[i, j]
	
	# wypelnianie
	count = 0
	for i in range(height2):
		for j in range(width2):
			if count == 0:
				resultImage2[int(scaleH*i), int(round(scaleW*j)) + 1] = self.im2[i, j]
				count += 1
			if count == 1:
				resultImage2[int(round(scaleH*i)) + 1, int(scaleW*j)] = self.im2[i, j]
				count = 0
	
	# interpolacja
	for i in range(height1):
		for j in range(width1):
			r, g, b = 0, 0, 0
			n = 0
			tmp[i, j] = resultImage2[i, j]
			if (resultImage2[i, j][0] < 1) & (resultImage2[i, j][1] < 1) & (resultImage2[i, j][2] < 1):
				for iOff in range(-1, 2):
					for jOff in range(-1, 2):
						iSafe = i if ((i + iOff) > (height1 - 2)) | ((i + iOff) < 0) else (i + iOff)
						jSafe = j if ((j + jOff) > (width1 - 2)) | ((j + jOff) < 0) else (j + jOff)
						if (resultImage2[iSafe, jSafe][0] > 0) | (resultImage2[iSafe, jSafe][1] > 0) | (resultImage2[iSafe, jSafe][2] > 0):
							r += resultImage2[iSafe, jSafe][0]
							g += resultImage2[iSafe, jSafe][1]
							b += resultImage2[iSafe, jSafe][2]
							n += 1
			tmp[i, j] = (r/n, g/n, b/n)
			resultImage2[i, j] = tmp[i, j]
	
	if show:
		self.show(Image.fromarray(resultImage1, "RGB"), Image.fromarray(resultImage2, "RGB"))
	self.save(resultImage1, self.im1Name, "unificationRas")
	self.save(resultImage2, self.im2Name, "unificationRas")

\end{lstlisting}

\newpage


\chapter{Operacje sumowania arytmetycznego obrazów szarych}
\hfill\\
\indent
Arytmetyczne operacje między pikslami $p$ i $q$ dwóch obrazów są używane w wielu działach przetwarzania obrazów. Przeprowadzane się je wykonując działania na pojedynczych pikslach i są uwarunkowane wymaganiami zależnymi od typu operacji. 
Po operacjach arytmetycznych zwykle niezbędna jest normalizacja. W przedstawionych zadaniach do normalizacji wykorzystano wzór:
	
	\begin{center}
		$ f_{norm} = Z_{rep}[(f - f_{min}) / (f_{max} - f_{min})] $
	\end{center}

\section {Sumowanie (określonej) stałej z obrazem}
\hfill\\
\indent
Algorytm sumowania obrazu szarego z określoną stałą polega na dodaniu do każdej wartości pojedynczego piksla stałej liczby.
Po operacji sumowania następuje normalizacja obrazu.

	\begin{enumerate}	
		\item Policz sumy wartości kazdego piksla ze stałą ($const$).
		\item Jeżeli jedna z tych sum jest większa niż 255 to:
		\item Wybierz największą sumę  $Q_{max}$ i policz $D_{max}$ ze wzoru: $D_{max}[i,j] = (Q_{max}[i,j] - 255)$ 
		\item Oblicz $X = D_{max} / 255$
		\item Policz sumy ze wzoru
		\begin{center}$Q[i,j] = P[i,j] - (P[i,j]* X) + const - (const * X) $ \\

		\end{center}
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Sum_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Sum_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po sumowaniu ze stałą = 50, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Sum_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Sum_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po sumowaniu ze stałą = 100, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Sumowanie obrazu szarego ze stałą]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
Q_max = 0
D_max = 0
X = 0
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  
        # Obliczanie sumy
        L = int(image_matrix[x][y]) + int(const)

        # Poszukiwanie maksimum
        if Q_max < L:
            Q_max = L

# Sprawdzenie czy przekracza zakres
if Q_max > 255:
    D_max = Q_max - 255
    X = (D_max/255)

# Obliczenie sumy z uwzglednieniem zakresu
for y in range(height):
    for x in range(width): 
        L = (image_matrix[x][y] - (image_matrix[x][y] * X)) + (const - (const * X))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}

\newpage

\section {Sumowanie dwóch obrazów}
\hfill\\
\indent

Algebraiczne sumowanie obrazów f i f' jest określone jedynie dla obrazów o tych samych wymiarach M x N i strukturze ich macierzy.
Dodawanie obrazów jest użyteczne w uśrednianiu obrazów, wykonywanym w celu zredukowania na nich szumu.
Algorytm sumowania obrazu z obrazem polega na dodaniu do wartości piksla z pierwszego obrazu, wartości odpowiadającego piksla z drugiego obrazu.
Po operacji sumowania następuje normalizacja obrazu.

	\begin{enumerate}	
		\item Policz sumy wartości kazdego piksla obrazu pierwszego P1[i,j] z pikslem obrazu drugiego P2[i,j].
		\item Jeżeli jedna z tych sum jest większa niż 255 to:
		\item Wybierz największą sumę  $Q_{max}$ i policz $D_{max}$ ze wzoru: $D_{max}[i,j] = (Q_{max}[i,j] - 255)$ 
		\item Oblicz $X = D_{max} / 255$
		\item Policz sumy ze wzoru
		\begin{center}$Q[i,j] = P1[i,j] - (P1[i,j]* X) + P2[i,j] - (P2[i,j] * X) $ \\

		\end{center}
	\end{enumerate}


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img1_Sum_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img2_Sum_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Sum_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to szare obrazy wejściowe, następnie obraz powstały w wyniku sumowania obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img1_Sum_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img2_Sum_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Sum_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to szare obrazy wejściowe, następnie obraz powstały w wyniku sumowania obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}


\begin{lstlisting}[caption=Sumowanie obrazów szarych]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
Q_max = 0
D_max = 0
X = 0
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sumy
        L = int(image1_matrix[x][y]) + int(image2_matrix[x][y])

        # Poszukiwanie maksimum
        if Q_max < L:
            Q_max = L

# Sprawdzenie czy przekracza zakres
if Q_max > 255:
    D_max = Q_max - 255
    X = (D_max/255)

# Obliczenie sumy z uwzglednieniem zakresu
for y in range(height):
    for x in range(width): 
        L = (image1_matrix[x][y] - (image1_matrix[x][y] * X)) + (image2_matrix[x][y] - (image2_matrix[x][y] * X))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)
        
        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\section {Mnożenie obrazu przez zadaną liczbę}
\hfill\\
\indent

Mnożenie obrazu f przez skalar wykonuje się mnożąc każdy element obrazu $f_{i,j}$ (wartość funkcji obrazowej piksla) przez ten skalar.

\begin{enumerate}
		\item Dla wszystkich pikseli w obrazie wykonaj:
		\item Jeżli składowa piksela $P_{1}[i,j]$ ma wartość 255 to składowa wynikowa otrzymuje wartość odpowiadającą wartości stalej.
		\item W przeciwnym przypadku, jeżeli składowa barwy piksla $P_{1}[i,j]$ ma wartość 0 to składowa wynikowa otrzymuje wartość 0.
		\item W przeciwnym wypadku mnóż odpowiednie składowe, a wynik dziel przez 255 zaokrąglajac do najbliższej liczby całkowitej.
	\end{enumerate}


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Multipl_Result} 
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po przemnożeniu przez liczbę=50, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po przemnożeniu przez liczbę=100, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Mnożenie obrazu szarego przez zadaną liczbę]

iimage1_matrix = self.im1
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

# Mnozenie 
for y in range(height):
    for x in range(width):  

        L = int(image1_matrix[x][y]) 
        if L == 255:
            L = const
        elif L == 0:
            L = 0
        else:
            L = (int(image1_matrix[x][y]) * const)/255 

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\section {Mnożenie obrazu przez inny obraz}
\hfill\\
\indent

Mnożenie obrazu f przez inny obraz wykonuje się mnożąc każdy element obrazu $P1_{i,j}$ (wartość funkcji obrazowej piksla) przez odpowiadającego piksla drugiego obrazu $P2_{i,j}$

	\begin{enumerate}
		\item Weź dwa identycznych rozmiarów obrazy $P_{1}$ i $P_{2}$.
		\item Dla wszystkich pikseli w obrazie wykonaj:
		\item Jeżli składowa piksela $P_{1}[i,j]$ ma wartość 255 to składowa wynikowa otrzymuje wartość odpowiadającą wartości składowej $P_{2}[i,j]$.
		\item W przeciwnym przypadku, jeżli składowa piksela $P_{1}[i,j]$ ma wartość 0 to składowa wynikowa otrzymuje wartość 0.
		\item W przeciwnym wypadku mnóż odpowiednie składowe, a wynik dziel przez 255 zaokrąglając do najbliższej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img1_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img2_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to szare obrazy wejściowe, następnie obraz powstały w wyniku przemnożenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img1_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img2_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to szare obrazy wejściowe, następnie obraz powstały w wyniku przemnożenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Mnożenie obrazu szarego przez inny obraz ]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        L = int(image1_matrix[x][y]) 
        if L == 255:
            L = image2_matrix[x][y]
        elif L == 0:
            L = 0
        else:
            L = (int(image1_matrix[x][y]) * int(image2_matrix[x][y]))/255 

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)
                        
        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

%\section {Mnożenie obrazu przez zadaną liczbę oraz przez inny obraz}
\section {Mieszanie obrazów z określonym współczynnikiem}
\hfill\\
\indent
\vspace{5mm}

Mieszanie dwóch obrazów polega na sumowaniu ich z wagami $\alpha$ i $(1 - \alpha)$, odpowiednio, wg wzoru:
	
	\begin{center}
		$f_{m} = f\alpha + f^I(1 - \alpha)$,
	\end{center}
	gdzie $\alpha \in [0,1]$. Płynna zmiana parametru $\alpha$ w przedziale $[0,1]$ powoduje efekt przechodzenia obrazu $f^I$ w obraz $f$. 
	
	\begin{enumerate}	
		\item Weź dwa identycznych rozmiarów obrazy $P_{1}$ i $P_{2}$.
		\item Określ współczynnik mieszania $\alpha$ wyrażony jako liczba rzeczywista z zakresu $< 0,1 >$; 0 reprezentuje pewną przezroczystość, 1 - nieprzezroczystości. 
		\item Dla wszystkich pikseli w obrazach wejściowych wykonuj $Q(i,j) = \alpha * P_{1}(i,j) + (1 - \alpha) * P_{2}(i,j)$
	\end{enumerate}


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img1_Mix_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img2_Mix_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Mix_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Mix_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku mieszania obrazów ze współczynnikiem $\alpha$=0.5, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img1_Mix_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img2_Mix_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Mix_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Mix_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku mieszania obrazów ze współczynnikiem $\alpha$=0.8, poniżej obraz wynikowy po normalizacji }
\end{figure}


\begin{lstlisting}[caption=Mieszanie obrazów szarych z określonym współczynnikiem]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        L = float(image1_matrix[x][y]) * alfa + (1-alfa) * float(image2_matrix[x][y])

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))
        
\end{lstlisting}
\newpage


\section {Potęgowanie obrazu (z zadaną potęgą)}
\hfill\\
\indent

		\begin{center} Potęgowanie obrazu jest szczególnym przypadkiem operacji mnożenia obrazów. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru ~\cite{WykRat}:

		$f_{m} = 255(\frac{f(x,y)}{f_{max}}) ^{\alpha}, \alpha > 0 $
	\end{center}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Pow_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Pow_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Pow_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po podniesieniu do potęgi $\alpha$=2, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Pow_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Pow_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Pow_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po podniesieniu do potęgi $\alpha$=3, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Potęgowanie obrazu szarego (z zadaną potęgą)]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

for y in range(height):
    for x in range(width):  
        
        L = int(image_matrix[x][y])

        # Poszukiwanie maksimum
        if f_img_max < L:
            f_img_max = L

for y in range(height):
    for x in range(width):  
        
        L = int(image_matrix[x][y])
        if L == 255:
            L = 255
        elif L == 0:
            L = 0
        else:
            L = math.pow(int(image_matrix[x][y]) / f_img_max, alfa) * 255

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))



\end{lstlisting}
\newpage

\section {Dzielenie obrazu przez (zadaną) liczbę }
\hfill\\
\indent
Dzielenie obrazów stosuje się w celu korekcji cieniowania między poziomami szarości.

\begin{enumerate}	
		
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Policz sumy piksli ze stałą.
		\item Wybierz największę sumę $Q_{max}$ i policz równania:\\
		$Q_[i,j] = ({S} * 255)/Q_{max}$,\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Div_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Div_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po podzieleniu przez liczbę=15, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Div_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Div_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po podzieleniu przez liczbę=3, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Dzielenie obrazu szarego przez (zadaną) liczbę ]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  

        L = int(image_matrix[x][y]) + int(const)

        # Poszukiwanie maksimum
        if Q_max < L:
            Q_max = L

for y in range(height):
    for x in range(width):  

        L = int(image_matrix[x][y]) + int(const)
        Q_L = (L * 255) / Q_max

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(Q_L)

        # Poszukiwanie minimum i maksimum
        if f_min > Q_L:
            f_min = Q_L
        if f_max < Q_L:
            f_max = Q_L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))
        
        
\end{lstlisting}

\newpage

\section {Dzielenie obrazu przez przez inny obraz}
\vspace{5mm}
	\begin{enumerate}	
		\item Weź dwa identycznych rozmiarów obrazy $P1$ i $P2$
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Policz sumy piksli ze stałą.
		\item Wybierz największę sumę $Q_{max}$ i policz równania:\\
		$Q_[i,j] = ({S} * 255)/Q_{max}$,\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img1_Div_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img2_Div_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Div_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku podzielenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img1_Div_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img2_Div_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Div_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku podzielenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}


\begin{lstlisting}[caption=Dzielenie obrazu szarego przez przez inny obraz]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  
        # Obliczanie sumy
        L = int(image1_matrix[x][y]) + int(image2_matrix[x][y])
        
        # Poszukiwanie maksimum
        if Q_max < L:
            Q_max = L

for y in range(height):
    for x in range(width):  

        # Obliczanie sumy
        L = int(image1_matrix[x][y]) + int(image2_matrix[x][y])
        Q_L = (L * 255) / Q_max

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(Q_L)

        # Poszukiwanie minimum i maksimum
        if f_min > Q_L:
            f_min = Q_L
        if f_max < Q_L:
            f_max = Q_L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\section {Pierwiastkowanie obrazu}
\hfill\\
\indent
		\begin{center} Pierwiastkowanie obrazu jest szczególnym przypadkiem operacji potęgowania obrazów, gdzie wykładnikiem jest ułamek. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru ~\cite{WykRat}:

		$f_{m} = 255(\frac{f(x,y)}{f_{max}}) ^{\alpha}, \alpha > 0 $
	\end{center}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Sqrt_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Sqrt_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Sqrt_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po spierwiastkowaniu pierwiastkiem kwadratowym ($\alpha$=1/2), obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Sqrt_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Sqrt_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Sqrt_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po spierwiastkowaniu pierwiastkiem stopnia trzeciego ($\alpha$=1/3), obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Pierwiastkowanie obrazu szarego]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

alfa = 1/deg # Zamiana stopnia pierwiastka na ulamek

for y in range(height):
    for x in range(width):  
        
        L = int(image_matrix[x][y])

        # Poszukiwanie maksimum
        if f_img_max < L:
            f_img_max = L

for y in range(height):
    for x in range(width):  
        
        L = int(image_matrix[x][y])
        if L == 255:
            L = 255
        elif L == 0:
            L = 0
        else:
            L = math.pow(int(image_matrix[x][y]) / f_img_max, alfa) * 255

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\section {Logarytmowanie obrazu}
\hfill\\
\indent
Logarytmowanie obrazu powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu.
Wykorzystano wzór z normalizacją ~/cite{WykRat}:
	
	\begin{center}
		$f_{m} = 255(frac{log(1 + f(x,y))}{log(1 + f_{max})})$
	\end{center}

	
Przesunięcie funkcji obrazowej $f$ do góry o 1 przed jej logarytmowaniem wynika z nieokreśloności logarytmu w zerze. Logarytmowanie obrazu powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu. .	


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Log_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Log_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Log_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Log_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Log_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Log_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Logarytmowanie obrazu szarego]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

for y in range(height):
    for x in range(width):  

        L = int(image_matrix[x][y]) 

        # Poszukiwanie maksimum
        if f_img_max < L:
            f_img_max = L

for y in range(height):
    for x in range(width):  

        L = int(image_matrix[x][y]) 

        if L == 0:
            L = 0
        else:
            L = (math.log(1 + L) / math.log(1 + f_img_max)) * 255

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))


\end{lstlisting}
\newpage

\chapter{Operacje sumowania arytmetycznego obrazów barwowych}
\hfill\\
\indent
Arytmetyczne operacje na obrazach barwowych przeprowadza się wykonując działania na pojedynczych pikslach i są uwarunkowane wymaganiami zależnymi od typu operacji. 
W przedstawionych zadaniach poruszamy się w przestrzeni barw RGB, a do normalizacji wykorzystano wzór:

	\begin{center}
		$ f_{norm} = Z_{rep}[(f - f_{min}) / (f_{max} - f_{min})] $
	\end{center}


\section{Sumowanie (określonej) stałej z obrazem}
\hfill\\
\indent
Algorytm sumowania obrazu barwowego z określoną stałą polega na dodaniu do każdej składowej barwowej pojedynczego piksla stałej liczby.
Po operacji sumowania obraz poddawany jest normalizacji.

	\begin{enumerate}	
		\item Policz sumy wartości kazdego piksla ze stałą ($const$).
		\item Jeżeli jedna z tych sum jest większa niż 255 to:
		\item Wybierz największą sumę  $Q_{max}$ i policz $D_{max}$ ze wzoru: $D_{max}[i,j] = (Q_{max}[i,j] - 255)$ 
		\item Oblicz $X = D_{max} / 255$
		\item Policz sumy ze wzoru
		\begin{center}$Q_{R}[i,j] = P_{R}[i,j] - (P_{R} * X)+ const - (const * X) -1$ \\
			$Q_{G}[i,j] = P_{G}[i,j] - (P_{G} * X)+ const - (const * X) -1$ \\
			$Q_{B}[i,j] = P_{B}[i,j] - (P_{B} * X)+ const - (const * X) -1$
		\end{center}
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Sum_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Sum_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po sumowaniu ze stałą = 50, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Sum_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Sum_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po sumowaniu ze stałą = 100, obraz po normalizacji }
\end{figure}

\begin{lstlisting}[caption=Sumowanie obrazu barwowego ze stałą]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
Q_max = 0
D_max = 0
X = 0
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R = int(image_matrix[x][y][0]) + int(const)
        G = int(image_matrix[x][y][1]) + int(const)
        B = int(image_matrix[x][y][2]) + int(const)

        # Poszukiwanie maksimum               
        if Q_max < max([R, G, B]):
            Q_max = max([R, G, B])

# Sprawdzenie czy maksimum przekracza zakres
if Q_max > 255:
    D_max = Q_max - 255
    X = (D_max/255) # Obliczenie proporcji

# Obliczenie sum z uwzglednieniem zakresu
for y in range(height):
    for x in range(width): 
        R = (image_matrix[x][y][0] - (image_matrix[x][y][0] * X)) + (const - (const * X))
        G = (image_matrix[x][y][1] - (image_matrix[x][y][1] * X)) + (const - (const * X))
        B = (image_matrix[x][y][2] - (image_matrix[x][y][2] * X)) + (const - (const * X))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\section {Sumowanie dwóch obrazów}
\hfill\\
\indent
Algebraiczne sumowanie obrazów f i f' jest określone jedynie dla obrazów o tych samych wymiarach M x N i strukturze ich macierzy.
Dodawanie obrazów jest użyteczne w uśrednianiu obrazów, wykonywanym w celu zredukowania na nich szumu.
Algorytm sumowania obrazu z obrazem polega na dodaniu do wartości piksla z pierwszego obrazu, wartości odpowiadającego piksla z drugiego obrazu.
Po operacji sumowania następuje normalizacja obrazu.

\begin{enumerate}	
		\item Weź dwa identycznych rozmiarów obrazy $P1$ i $P2$
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Policz sumy odpowiadających składowych barwy.
		\item Wybierz największą sumę $Q_{max} = max(R_{s}, G_{s}, B_{s})$ i policz równania:\\
		$Q_{R}[i,j] = (R_{S} * 255)/Q_{max}$,\\
		$Q_{G}[i,j] = (G_{S} * 255)/Q_{max}$,\\
		$Q_{B}[i,j] = (B_{S} * 255)/Q_{max}$.\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sum_Img1_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sum_Img2_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sum_Img_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sum_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to barwowe obrazy wejściowe, następnie obraz powstały w wyniku sumowania obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sum_Img1_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sum_Img2_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sum_Img_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sum_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to barwowe obrazy wejściowe, następnie obraz powstały w wyniku sumowania obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}


\begin{lstlisting}[caption=Sumowanie obrazów barwowych]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
Q_max = 0
D_max = 0
X = 0
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R = int(image1_matrix[x][y][0]) + int(image2_matrix[x][y][0])
        G = int(image1_matrix[x][y][1]) + int(image2_matrix[x][y][1])
        B = int(image1_matrix[x][y][2]) + int(image2_matrix[x][y][2])
        
        # Poszukiwanie maksimum               
        if Q_max < max([R, G, B]):
            Q_max = max([R, G, B])

# Sprawdzenie czy maximum przekracza zakres
if Q_max > 255:
    D_max = Q_max - 255
    X = (D_max/255) # Obliczenie proporcji

# Obliczenie sum z uwzglednieniem zakresu
for y in range(height):
    for x in range(width): 
        R = (image1_matrix[x][y][0] - (image1_matrix[x][y][0] * X)) + (image2_matrix[x][y][0] - (image2_matrix[x][y][0] * X))
        G = (image1_matrix[x][y][1] - (image1_matrix[x][y][1] * X)) + (image2_matrix[x][y][1] - (image2_matrix[x][y][1] * X))
        B = (image1_matrix[x][y][2] - (image1_matrix[x][y][2] * X)) + (image2_matrix[x][y][2] - (image2_matrix[x][y][2] * X))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\section {Mnożenie obrazu przez zadaną liczbę}
\hfill\\
\indent
Mnożenie obrazu f przez skalar wykonuje się mnożąc każdy element obrazu $f_{i,j}$ (wartość funkcji obrazowej piksla) przez ten skalar. Barwa wynikowa jest zawsze barwą ciemniejszą.

\begin{enumerate}
		\item Dla wszystkich pikseli w obrazie wykonaj:
		\item Jeżli składowa barwy piksela $P_{1}[i,j]$ ma wartość 255 to składowa wynikowa otrzymuje wartość odpowiadającą wartości stalej.
		\item W przeciwnym przypadku, jeżeli składowa barwy piksla $P_{1}[i,j]$ ma wartość 0 to składowa wynikowa otrzymuje wartość 0.
		\item W przeciwnym wypadku mnóż odpowiednie składowe, a wynik dziel przez 255 zaokrąglajac do najbliższej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po przemnożeniu przez liczbę 50, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po przemnożeniu przez liczbę 100, obraz po normalizacji }

\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Mnożenie obrazu barwowego przez zadaną liczbę]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        R = int(image_matrix[x][y][0])
        G = int(image_matrix[x][y][1])
        B = int(image_matrix[x][y][2])

        if R == 255:
            R = const
        elif R == 0:
            R = 0
        else:
            R = (int(image_matrix[x][y][0]) * int(const))/255 
        
        if G == 255:
            G = const
        elif G == 0:
            G = 0
        else:
            G = (int(image_matrix[x][y][1]) * int(const))/255 
        
        if B == 255:
            B = const
        elif B == 0:
            B = 0
        else:
            B = (int(image_matrix[x][y][2]) * int(const))/255 

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))


\end{lstlisting}
\newpage

\section {Mnożenie obrazu przez inny obraz}
\hfill\\
\indent
Mnożenie obrazu f przez inny obraz wykonuje się mnożąc każdy element obrazu $P1_{i,j}$ (wartość funkcji obrazowej piksla) przez odpowiadającego piksla drugiego obrazu $P2_{i,j}$

	\begin{enumerate}
		\item Dla wszystkich pikseli w obrazie wykonaj:
		\item Jeżli składowa piksela $P_{1}[i,j]$ ma wartość 255 to składowa wynikowa otrzymuje wartość odpowiadającą wartości składowej $P_{2}[i,j]$.
		\item W przeciwnym przypadku, jeżli składowa piksela $P_{1}[i,j]$ ma wartość 0 to składowa wynikowa otrzymuje wartość 0.
		\item W przeciwnym wypadku mnóż odpowiednie składowe, a wynik dziel przez 255 zaokrąglając do najbliższej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Multipl_Img1_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Multipl_Img2_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Multipl_Img_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Multipl_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to barwowe obrazy wejściowe, następnie obraz powstały w wyniku przemnożenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Multipl_Img1_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Multipl_Img2_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Multipl_Img_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Multipl_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to barwowe obrazy wejściowe, następnie obraz powstały w wyniku przemnożenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Mnożenie obrazu barwowego przez inny obraz ]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        if R == 255:
            R = image2_matrix[x][y][0]
        elif R == 0:
            R = 0
        else:
            R = (int(image1_matrix[x][y][0]) * int(image2_matrix[x][y][0]))/255 
        
        if G == 255:
            G = image2_matrix[x][y][1]
        elif G == 0:
            G = 0
        else:
            G = (int(image1_matrix[x][y][1]) * int(image2_matrix[x][y][1]))/255 
        
        if B == 255:
            B = image2_matrix[x][y][2]
        elif B == 0:
            B = 0
        else:
            B = (int(image1_matrix[x][y][2]) * int(image2_matrix[x][y][2]))/255 

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))


\end{lstlisting}
\newpage

\section{ Mieszanie obrazów z określonym współczynnikiem}
\hfill\\
\indent
Mieszanie dwóch obrazów polega na sumowaniu ich z wagami $\alpha$ i $(1 - \alpha)$, odpowiednio, wg wzoru:
	
	\begin{center}
		$f_{m} = f\alpha + f^I(1 - \alpha)$,
	\end{center}
	gdzie $\alpha \in [0,1]$. Płynna zmiana parametru $\alpha$ w przedziale $[0,1]$ powoduje efekt przechodzenia obrazu $f^I$ w obraz $f$. W mieszaniu obrazów nie ma problemu normalizacji, a jedynie jednolitosci struktur i typów obrazowych. 
	
	\begin{enumerate}	
		\item Weź dwa identycznych rozmiarów obrazy $P_{1}$ i $P_{2}$.
		\item Okrelśl współczynnik mieszania $\alpha$ wyrażony jako liczba rzeczywista z zakresu $ < 0,1 > $; 0 reprezentuje pewną przezroczystość, 1 - nieprzezroczystości. 
		\item Dla wszystkich pikseli w obrazach wejściowych wykonuj $Q(i,j) = \alpha * P_{1}(i,j) + (1 - \alpha) * P_{2}(i,j)$
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Mix_Img1_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Mix_Img2_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Mix_Img_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Mix_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku mieszania obrazów ze współczynnikiem $\alpha$=0.5, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Mix_Img1_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Mix_Img2_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Mix_Img_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Mix_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku mieszania obrazów ze współczynnikiem $\alpha$=0.8, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{lstlisting}[caption=Mieszanie obrazów barwowych z określonym współczynnikiem]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        R = float(image1_matrix[x][y][0]) * alfa + (1-alfa) * float(image2_matrix[x][y][0])
        G = float(image1_matrix[x][y][1]) * alfa + (1-alfa) * float(image2_matrix[x][y][1])
        B = float(image1_matrix[x][y][2]) * alfa + (1-alfa) * float(image2_matrix[x][y][2])

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))


\end{lstlisting}
\newpage

\section{ Potęgowanie obrazu}

\hfill\\
\indent

\begin{center} Potęgowanie obrazu jest szczególnym przypadkiem operacji mnożenia obrazów. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru ~\cite{WykRat}:
		$f_{m} = 255(\frac{f(x,y)}{f_{max}}) ^{\alpha}, \alpha > 0 $
	\end{center}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Pow_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Pow_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Pow_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po podniesieniu do potęgi $\alpha$=2, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Pow_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Pow_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Pow_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po podniesieniu do potęgi $\alpha$=3, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Potęgowanie obrazu barwowego]

image1_matrix = self.im1
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

for y in range(height):
    for x in range(width):  

        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        if f_img_max < max([R, G, B]):
            f_img_max = max([R, G, B])

for y in range(height):
    for x in range(width):  

        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        if R == 0:
            R = 0
        else:
            R = 255 * (math.pow(int(image1_matrix[x][y][0]) / f_img_max, alfa))

        if G == 0:
            G = 0
        else:
            G = 255 * (math.pow(int(image1_matrix[x][y][1]) / f_img_max, alfa))
        
        if B == 0:
            B = 0
        else:
            B = 255 * (math.pow(int(image1_matrix[x][y][2]) / f_img_max, alfa))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))


\end{lstlisting}
\newpage

\section{ Dzielenie obrazu przez (zadaną) liczbę}

\hfill\\
\indent

Dzielenie obrazów stosuje się w celu korekcji cieniowania między poziomami szarości.

\begin{enumerate}	
		
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Policz sumy piksli ze stałą.
		\item Wybierz największę sumę  $Q_{max} = max(R_{s}, G_{s}, B_{s})$ i policz równania:\\
		$Q_{R}[i,j] = (R_{S} * 255)/Q_{max}$,\\
		$Q_{G}[i,j] = (G_{S} * 255)/Q_{max}$,\\
		$Q_{B}[i,j] = (B_{S} * 255)/Q_{max}$.,\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po podzieleniu przez liczbę=15, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po podzieleniu przez liczbę=3, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=  Dzielenie obrazu barwowego przez (zadaną) liczbę]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image_matrix[x][y][0]) + int(const)
        G_S = int(image_matrix[x][y][1]) + int(const)
        B_S = int(image_matrix[x][y][2]) + int(const)

        # Poszukiwanie maksimum
        if Q_max < max([R_S, G_S, B_S]):
            Q_max = max([R_S, G_S, B_S])

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image_matrix[x][y][0]) + int(const)
        G_S = int(image_matrix[x][y][1]) + int(const)
        B_S = int(image_matrix[x][y][2]) + int(const)

        Q_R = (R_S * 255)/Q_max
        Q_G = (G_S * 255)/Q_max
        Q_B = (B_S * 255)/Q_max
            
        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(Q_R)
        result_matrix[x][y][1] = math.ceil(Q_G)
        result_matrix[x][y][2] = math.ceil(Q_B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([Q_R, Q_G, Q_B]):
            f_min = min([Q_R, Q_G, Q_B])
        if f_max < max([Q_R, Q_G, Q_B]):
            f_max = max([Q_R, Q_G, Q_B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\section{ Dzielenie obrazu przez inny obraz }

\hfill
\\\\
\indent

\begin{enumerate}	
		
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Weź dwa identycznych rozmiarów obrazy $P1$ i $P2$
		\item Policz sumy piksli ze stałą.
		\item Wybierz największę sumę  $Q_{max} = max(R_{s}, G_{s}, B_{s})$ i policz równania:\\
		$Q_{R}[i,j] = (R_{S} * 255)/Q_{max}$\\
		$Q_{G}[i,j] = (G_{S} * 255)/Q_{max}$\\
		$Q_{B}[i,j] = (B_{S} * 255)/Q_{max}$\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Img1_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Img2_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Img_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku dzielenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Img1_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Img2_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Img_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku dzielenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{lstlisting}[caption= Dzielenie obrazu barwowego przez inny obraz]


image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image1_matrix[x][y][0]) + int(image2_matrix[x][y][0])
        G_S = int(image1_matrix[x][y][1]) + int(image2_matrix[x][y][1])
        B_S = int(image1_matrix[x][y][2]) + int(image2_matrix[x][y][2])

        # Poszukiwanie maksimum
        if Q_max < max([R_S, G_S, B_S]):
            Q_max = max([R_S, G_S, B_S])

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image1_matrix[x][y][0]) + int(image2_matrix[x][y][0])
        G_S = int(image1_matrix[x][y][1]) + int(image2_matrix[x][y][1])
        B_S = int(image1_matrix[x][y][2]) + int(image2_matrix[x][y][2])

        Q_R = (R_S * 255)/Q_max
        Q_G = (G_S * 255)/Q_max
        Q_B = (B_S * 255)/Q_max

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(Q_R)
        result_matrix[x][y][1] = math.ceil(Q_G)
        result_matrix[x][y][2] = math.ceil(Q_B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([Q_R, Q_G, Q_B]):
            f_min = min([Q_R, Q_G, Q_B])
        if f_max < max([Q_R, Q_G, Q_B]):
            f_max = max([Q_R, Q_G, Q_B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\section{ Pierwiastkowanie obrazu}

\hfill
\\\\
\indent

\begin{center} Pierwiastkowanie obrazu jest szczególnym przypadkiem operacji potęgowania obrazów, gdzie wykładnikiem jest ułamek. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru ~\cite{WykRat}:

		$f_{m} = 255(\frac{f(x,y)}{f_{max}}) ^{\alpha}, \alpha > 0 $
	\end{center}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sqrt_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sqrt_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sqrt_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po spierwiastkowaniu pierwiastkiem kwadratowym ($\alpha$=1/2), obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sqrt_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sqrt_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sqrt_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po spierwiastkowaniu pierwiastkiem stopnia trzeciego ($\alpha$=1/3), obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Pierwiastkowanie obrazu barwowego]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image_matrix[x][y][0]) + int(const)
        G_S = int(image_matrix[x][y][1]) + int(const)
        B_S = int(image_matrix[x][y][2]) + int(const)

        # Poszukiwanie maksimum
        if Q_max < max([R_S, G_S, B_S]):
            Q_max = max([R_S, G_S, B_S])

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image_matrix[x][y][0]) + int(const)
        G_S = int(image_matrix[x][y][1]) + int(const)
        B_S = int(image_matrix[x][y][2]) + int(const)

        Q_R = (R_S * 255)/Q_max
        Q_G = (G_S * 255)/Q_max
        Q_B = (B_S * 255)/Q_max
            
        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(Q_R)
        result_matrix[x][y][1] = math.ceil(Q_G)
        result_matrix[x][y][2] = math.ceil(Q_B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([Q_R, Q_G, Q_B]):
            f_min = min([Q_R, Q_G, Q_B])
        if f_max < max([Q_R, Q_G, Q_B]):
            f_max = max([Q_R, Q_G, Q_B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\section{ Logarytmowanie obrazu}

\hfill\\
\indent
Logarytmowanie obrazu powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu.
Wykorzystano wzór z normalizacją ~/cite{WykRat}:
	
	\begin{center}
		$f_{m} = 255(frac{log(1 + f(x,y))}{log(1 + f_{max})})$
	\end{center}

	
Przesunięcie funkcji obrazowej $f$ do góry o 1 przed jej logarytmowaniem wynika z nieokreśloności logarytmu w zerze. Logarytmowanie obrazu powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu.	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Log_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Log_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Log_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Log_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Log_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Log_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Logarytmowanie obrazu barwowego]


image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

for y in range(height):
    for x in range(width):  
        
        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        # Poszukiwanie maksimum                
        if f_img_max < max([R, G, B]):
            f_img_max = max([R, G, B])

for y in range(height):
    for x in range(width):  
        
        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        if R == 0:
            R = 0
        else:
            R = math.log(1 + int(image1_matrix[x][y][0])) / math.log(1 + int(f_img_max)) * 255

        if G == 0:
            G = 0
        else:
            G = math.log(1 + int(image1_matrix[x][y][1])) / math.log(1 + int(f_img_max)) * 255
        
        if B == 0:
            B = 0
        else:
            B = math.log(1 + int(image1_matrix[x][y][2])) / math.log(1 + int(f_img_max)) * 255

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])


# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}
\newpage

\chapter{Operacje geometryczne na obrazie}
\hfill\\
\indent
Transformacje geometryczne są szczególnie wykorzystywane w przypadku dopasowywania obrazu do układu współrzędnych oraz w przypadku eliminowania zniekształceń geometrycznych obrazu. W przedstawionych operacjach obrazy umieszczane są w pierwszej ćwiartce układu współrzędnych.

\section{ Przemieszczenie obrazu o zadany wektor}
\hfill\\
\indent

Przesuwanie obrazu polega na zmianie współrzędnych każdego piksela obrazu o określoną wartość zgodnie z zależnościami:
	
	\begin{center}
		$x^I = x_{o} + \Delta x$\\
		$y^I = y_{o} + \Delta y$
	\end{center}
	
	gdzie $(x_{o},y_{o})$ - współrzędnych początkowe piksla; ($\Delta{x},\Delta{y}$) - wartości przesunięcia; $(x^I,y^I)$ - współrzędne piksla po przesunięciu;

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Move_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Move_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz po przesunięciu o wektor [40, 70] }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Move_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Move_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz po przesunięciu o wektor [200, 100] }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Przemieszczenie obrazu o zadany wektor]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

delta_y = 0 - delta_y # Poruszamy sie w pierwszej cwartce ukladu wspolrzednych

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

for y in range(height):
    for x in range(width):  
        if 0 < y+delta_y < height and 0 < x+delta_x < width:
            result_matrix[y+delta_y][x+delta_x] = image_matrix[y][x]

\end{lstlisting}
\newpage

\section{ Jednorodne skalowanie obrazu}
\hfill\\
\indent
Skalowanie jednorodne obrazu polega na pomnożeniu współrzędnych każdego piksla obrazu przez współczynnik skalowania $S$ wg. wzoru:
	
	\begin{center}
		$x^I = x_{o} * S$ \\
		$y^I = y_{o} * S$
	\end{center}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleJ_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleJ_Result}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleJ_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz skalowaniu jednorodnym ze współczynnikiem S=1.5 , obraz po interpolacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleJ_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleJ_Result}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleJ_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz skalowaniu jednorodnym ze współczynnikiem S=2, obraz po interpolacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Jednorodne skalowanie obrazu]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

# result_matrix = np.empty((math.ceil(height/scale_y), math.ceil(width/scale_x), 3), dtype=np.uint8)
result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

for y in range(height):
    for x in range(width): 
        if scale*y < height and scale*x < width:
            # result_matrix[y][x] = image_matrix[scale*y][scale*x]
            result_matrix[int(scale*y)][int(scale*x)] = image_matrix[y][x]

resultImage2 = np.copy(result_matrix)
tmp = np.ones((height, width, 3), dtype = np.uint8)

# Interpolacja
for i in range(height):
    for j in range(width):
        r, g, b = 0, 0, 0
        n = 1
        tmp[i, j] = resultImage2[i, j]
        if (resultImage2[i, j][0] < 1) & (resultImage2[i, j][1] < 1) & (resultImage2[i, j][2] < 1):
            for iOff in range(-1, 2):
                for jOff in range(-1, 2):
                    iSafe = i if ((i + iOff) > (height - 2)) | ((i + iOff) < 0) else (i + iOff)
                    jSafe = j if ((j + jOff) > (width - 2)) | ((j + jOff) < 0) else (j + jOff)
                    if (resultImage2[iSafe, jSafe][0] > 0) | (resultImage2[iSafe, jSafe][1] > 0) | (resultImage2[iSafe, jSafe][2] > 0):
                        r += resultImage2[iSafe, jSafe][0]
                        g += resultImage2[iSafe, jSafe][1]
                        b += resultImage2[iSafe, jSafe][2]
                        n += 1
            tmp[i, j] = (r/n, g/n, b/n)
            resultImage2[i, j] = tmp[i, j]

\end{lstlisting}
\newpage

\section{ Niejednorodne skalowanie obrazu}
\hfill\\
\indent
Skalowanie niejednorodne obrazu polega na pomnożeniu współrzędnych każdego piksla obrazu przez współczynniki skalowania $S_{x}, S_{y}$ wg. wzoru:

\begin{center}
	$x^I = x_{o} * S_{x}$ \\
	$y^I = y_{o} * S_{y}$
\end{center}

gdzie $(x_{o},y_{o})$ - współrzędne początkowe piksela; ($S_{x}, S_{y}$) - wartości współczynników skalowania; $(x^I,y^I)$ - współrzędne piksla po skalowaniu;

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleNJ_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleNJ_Result}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleNJ_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz skalowaniu niejednorodnym ze współczynnikiem $S_{x}$=2 oraz współczynnikiem $S_{y}$=1 , obraz po interpolacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleNJ_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleNJ_Result}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleNJ_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz skalowaniu niejednorodnym ze współczynnikiem $S_{x}$=1 oraz współczynnikiem $S_{y}$=2 , obraz po interpolacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Niejednorodne skalowanie obrazu]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

# result_matrix = np.empty((math.ceil(height/scale_y), math.ceil(width/scale_x), 3), dtype=np.uint8)
result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

for y in range(height):
    for x in range(width): 
        if scale_y*y < height and scale_x*x < width:
            # result_matrix[y][x] = image_matrix[scale_y*y][scale_x*x]
            result_matrix[int(scale_y*y)][int(scale_x*x)] = image_matrix[y][x]

resultImage2 = np.copy(result_matrix)
tmp = np.ones((height, width, 3), dtype = np.uint8)

# Interpolacja
for i in range(height):
    for j in range(width):
        r, g, b = 0, 0, 0
        n = 1
        tmp[i, j] = resultImage2[i, j]
        if (resultImage2[i, j][0] < 1) & (resultImage2[i, j][1] < 1) & (resultImage2[i, j][2] < 1):
            for iOff in range(-1, 2):
                for jOff in range(-1, 2):
                    iSafe = i if ((i + iOff) > (height - 2)) | ((i + iOff) < 0) else (i + iOff)
                    jSafe = j if ((j + jOff) > (width - 2)) | ((j + jOff) < 0) else (j + jOff)
                    if (resultImage2[iSafe, jSafe][0] > 0) | (resultImage2[iSafe, jSafe][1] > 0) | (resultImage2[iSafe, jSafe][2] > 0):
                        r += resultImage2[iSafe, jSafe][0]
                        g += resultImage2[iSafe, jSafe][1]
                        b += resultImage2[iSafe, jSafe][2]
                        n += 1
            tmp[i, j] = (r/n, g/n, b/n)
            resultImage2[i, j] = tmp[i, j]

\end{lstlisting}
\newpage

\section{ Obracanie obrazu o dowolny kąt}
\hfill\\
\indent

Operację obrotu dookoła początku układu współrzędnych wykonuje się zgodnie ze wzorem:
	
	\begin{center}
		$x^I = x_{o} * cos\alpha - y_{o} * sin\alpha$\\
		$y^I = x_{o} * sin\alpha + y_{o} * cos\alpha$
	\end{center}
	
	gdzie $(x_{o},y_{o})$ - współrzędne początkowe piksla; $\alpha$ - kąt obrotu; $(x^I,y^I)$ - współrzędne piksela po obrocie;

W przedstawionych przykładach punkt obrotu został przesunięty na środek obrazu według wzoru:

	\begin{center}
        $new_x = (x - width/2) * math.cos(alfa_r) - (y - height/2) * math.sin(alfa_r) + (width/2)$\\
        $new_y = (x - width/2) * math.sin(alfa_r) + (y - height/2) * math.cos(alfa_r) + (height/2)$\\
	\end{center}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Turn_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Turn_Result}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Turn_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz po obróceniu wokół  środka obrazu o kąt 40 stopni, obraz po interpolacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Turn_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Turn_Result}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Turn_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz po obróceniu wokół  środka obrazu o kąt 110 stopni, obraz po interpolacji }
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Obracanie obrazu o dowolny kąt]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

# Przeksztalcenie na radiany
alfa_r = math.radians(alfa)

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)


for y in range(height):
    for x in range(width): 
        new_x = (x - width/2) * math.cos(alfa_r) - (y - height/2) * math.sin(alfa_r) + (width/2)
        new_y = (x - width/2) * math.sin(alfa_r) + (y - height/2) * math.cos(alfa_r) + (height/2)
        if new_y < height and new_y >= 0 and new_x >= 0 and new_x < width:
            result_matrix[int(new_y)][int(new_x)] = image_matrix[y][x]

resultImage2 = np.copy(result_matrix)
tmp = np.ones((height, width, 3), dtype = np.uint8)

# Interpolacja
for i in range(height):
    for j in range(width):
        r, g, b = 0, 0, 0
        n = 1
        tmp[i, j] = resultImage2[i, j]
        if (resultImage2[i, j][0] < 1) & (resultImage2[i, j][1] < 1) & (resultImage2[i, j][2] < 1):
            for iOff in range(-1, 2):
                for jOff in range(-1, 2):
                    iSafe = i if ((i + iOff) > (height - 2)) | ((i + iOff) < 0) else (i + iOff)
                    jSafe = j if ((j + jOff) > (width - 2)) | ((j + jOff) < 0) else (j + jOff)
                    if (resultImage2[iSafe, jSafe][0] > 0) | (resultImage2[iSafe, jSafe][1] > 0) | (resultImage2[iSafe, jSafe][2] > 0):
                        r += resultImage2[iSafe, jSafe][0]
                        g += resultImage2[iSafe, jSafe][1]
                        b += resultImage2[iSafe, jSafe][2]
                        n += 1
            tmp[i, j] = (r/n, g/n, b/n)
            resultImage2[i, j] = tmp[i, j]


\end{lstlisting}
\newpage

\section{ Symetrie względem osi układu}

\subsection*{ Symetria względem osi X}
\hfill\\
\indent
Względem osi OX pikslem symetrycznym do piksla $P_{1}(x,y)$ jest piksel $P_{2}(x,-y)$
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ox_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ox_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem osi X }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ox_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ox_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem osi X }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Symetrie względem osi X]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)
_height = height-1 #array height last index

for y in range(height):
    for x in range(width): 
            result_matrix[y][x] = image_matrix[_height-y][x]

\end{lstlisting}
\newpage

\subsection*{ Symetria względem osi Y}
\hfill\\
\indent
Względem osi OY pikslem symetrycznym do piksla $P_{1}(x,y)$ jest piksel $P_{2}(-x,y)$


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_oy_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_oy_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem osi Y }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_oy_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_oy_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem osi Y }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Symetrie względem osi Y]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)
_width = width - 1 #array width last index

for y in range(height):
    for x in range(width): 
            result_matrix[y][x] = image_matrix[y][_width - x]

\end{lstlisting}
\newpage

\section{ Symetrie względem zadanej prostej}
\hfill\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_px_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_px_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem pionowej prostej poprowadzonej przez środek obrazu }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_px_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_px_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem pionowej prostej poprowadzonej przez środek obrazu }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_py_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_py_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem poziomej prostej poprowadzonej przez środek obrazu }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_py_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_py_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem poziomej prostej poprowadzonej przez środek obrazu }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Symetrie względem zadanej prostej]


image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

#Symetria wzgledem poziomej prostej poprowadzonej przez srodek obrazu
result_matrix = np.zeros((height, width, 3), dtype=np.uint8)
_height = height - 1 #array height last index

param_y = height/2

for y in range(height):
    for x in range(width): 
        if y < param_y:
            result_matrix[y][x] = image_matrix[y][x]
        else:
            result_matrix[y][x] = image_matrix[_height - y][x]

#Symetria wzgledem pionowej prostej poprowadzonej przez srodek obrazu
result_matrix = np.zeros((height, width, 3), dtype=np.uint8)
_width = width - 1 #array width last index

param_x = width/2

for y in range(height):
    for x in range(width): 
        if x < param_x:
            result_matrix[y][x] = image_matrix[y][x]
        else:
            result_matrix[y][x] = image_matrix[y][_width - x]

\end{lstlisting}
\newpage


\section{ Wycinanie fragmentów obrazu}
\hfill\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Cut_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Cut_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz po wycięciu fragmentu o współrzędnych $x_{min}=100, x_{max}=250, y_{min}=25, y_{max}=450$ }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Cut_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Cut_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz po wycięciu fragmentu o współrzędnych $x_{min}=200, x_{max}=400, y_{min}=200, y_{max}=400$ }
\end{figure}


\subsection*{Kod źródłowy}


\begin{lstlisting}[caption= Wycinanie fragmentów obrazu]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

for y in range(height):
    for x in range(width): 
        # Poruszamy sie w pierwszej cwiartce osi ukladu wspolrzednych
        if x > x_min and x < x_max and y < height-y_min and y > height-y_max:
            result_matrix[y][x] = 0
        else:
            result_matrix[y][x] = image_matrix[y][x]

\end{lstlisting}
\newpage

\section{ Kopiowanie fragmentów obrazów}
\hfill\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Copy_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Copy_Result}
		\includegraphics[height=4cm]{1/1Geo_Copy_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz (512x512) ze skopiowanym fragmentem o współrzędnych $x_{min}=100, x_{max}=250, y_{min}=25, y_{max}=450$, Skopiowany fragment (151x426) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Copy_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Copy_Result}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Copy_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz (512x512) ze skopiowanym fragmentem o współrzędnych $x_{min}=200, x_{max}=400, y_{min}=200, y_{max}=400$, Skopiowany fragment (201x201) }
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Kopiowanie fragmentów obrazów]


image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

# Macierz o wymiarach wycinanego fragmentu
cut_matrix = np.zeros((y_max-y_min + 1, x_max-x_min + 1, 3), dtype=np.uint8)

cut_y = 0
for y in range(height):
    cut_x = 0
    for x in range(width): 
        # Poruszamy sie w pierwszej cwiartce osi ukladu wspolrzednych
        if x >= x_min and x <= x_max and y <= height-y_min and y >= height-y_max:    
            result_matrix[y][x] = image_matrix[y][x]
            cut_matrix[cut_y][cut_x] = image_matrix[y][x]
            cut_x+=1
    if cut_x > 0:    
        cut_y+=1

\end{lstlisting}
\newpage

\chapter{Operacje na histogramie obrazu szarego}
Histogram to najprostszy opis całościowy obrazu. Dlatego stosuje się go, by rozpoznać, jakie dalsze metody i operacje należy zastosować na przetwarzanym obrazie, by osiągnać założony cel. Jego obliczenie polega na odczytaniu szarości każdego piksla i rejestrowaniu jej wystąpienia o danym poziomie.\\
Histogram to funkcja przypisująca każdemu poziomowi szarości obrazu, liczbę piksli z danym poziomem szarości, czyli jest to wykres częstości występowania wartości piksli w obrazie.
\newpage


\section{Obliczanie histogramu}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent 
Histogram obrazu szarego jest wykresem częstości występowania wartości szarości piksli w obrazie tj.
przyporządkowuje liczbę piskli do danego poziomu szarości.\newline
\begin{enumerate}
	\item Zaalokuj tablicę 256 elementową (tyle, ile poziomów szarości w obrazie)
	\item Dla każdego piskla:
	\item Zinkrementuj element tablicy o indeksie równym pozionie szarości danego piskla
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{gentelman_gray}
		\includegraphics[width=0.4\textwidth]{gentelman_gray_histogram}
	\end{center}
	\caption{Obraz szary, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{pirate_gray}
		\includegraphics[width=0.4\textwidth]{pirate_gray_histogram}
	\end{center}
	\caption{Obraz szary, histogram szarości tego obrazu}
\end{figure}
\newpage

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Obliczanie histogramu]
	
def calculate(self, plot = False, image = None):
	if image is None:
		image = self.im
	
	width = image.shape[1]      # szereoksc
	height = image.shape[0]     # wysokosc
	hist = [0] * 256            # hostogram szarosci
	
	for i in range(height):
		for j in range(width):
			bin = image[i, j]   # odcien szarosci
			hist[bin] += 1
	
	if plot:
		# tablica [0, 1, ... , 254, 255]
		bins = np.arange(256)
		self.plotHistogram(bins, hist)
	
	return hist
	
\end{lstlisting}

\newpage





\section{Przemieszczanie histogramu}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Przemieszczenie histogramu polega na dodaniu lub odjęciu tej samej wartości od poziomu szarości każdego piksla w obrazie.
W rezultacie obraz jest odpowiednio równomiernie rozjaśniony bądź przyciemniony.
Nie można przekroczyć przyjętego zakresu poziomów szarości.
\begin{enumerate}
	\item Do każdej wartości piksla dodaj podaną stałą o którą chcesz przemieścić histogram.
	\item Jeśli wartość piksla po operacji dodawania wykracza poza zakres 255:
	\item Przypisz jej wartość 255.
	\item Jeśli wartość piksla po operacji dodawania jest mniejsza od 0:
	\item Przypisz jej wartość 0.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{gentelman_gray}
		\includegraphics[width=0.4\textwidth]{gentelman_gray_histogram}
	\end{center}
	\caption{Obraz szary wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{gentelman_gray_moveHist_result}
		\includegraphics[width=0.4\textwidth]{gentelman_gray_moveHist_histogram}
	\end{center}
	\caption{Obraz szary przesunięty o 100, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[t]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{pirate_gray}
		\includegraphics[width=0.4\textwidth]{pirate_gray_histogram}
	\end{center}
	\caption{Obraz szary wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{pirate_gray_moveHist_result}
		\includegraphics[width=0.4\textwidth]{pirate_gray_moveHist_histogram}
	\end{center}
	\caption{Obraz szary pryesunięty o -100, histogram szarości tego obrazu}
\end{figure}



%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Przemieszczanie histogramu]
def move(self, const = 0, show = False, plot = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	# przemieszczanie
	for i in range(height):
		for j in range(width):
			value = int(self.im[i, j]) + const
			if value < 0:
				value = 0
			elif value > 255:
				value = 255
			resultImage[i, j] = value
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "moveHist")
\end{lstlisting}

\newpage





\section{Rozciąganie histogramu}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Rozciągania histogramu dokonuje się na obrazie, którego poziomy szarości nie są rozpięte na cały możliwy zakres np.
[51, 233]. Operacja rozciągnięcia histogramu rozciągnie histogram tak, aby był rozpięty na cały możliwy zakres poziomów szarości np. [0, 255].
\begin{enumerate}
	\item Znajdź w obrazie największą($max$) i najmniejszą($min$) wartość piksla
	\item Dla każdego piksla:
	\item Oblicz nową wartość piskla stosując wzór:\\
	\centerline{$P_n = 255$ $//$ $(max - min) * (P_o - min)$.}
	W taki sposób, jeśli odcienie szarości obrazu wejściowego były w zakresie
	np. $[12, 239]$, po operacji rozciągania histogramu, odcienie szarości będą w zakresie\\
	$[0, 255]$
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_moveHist_result}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_moveHist_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_stretchHist_result}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_stretchHist_histogram}
	\end{center}
	\caption{Obraz po rozciągnięciu, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray_stretchHist_result}
		\includegraphics[width=0.35\textwidth]{pirate_gray_stretchHist_histogram}
	\end{center}
	\caption{Obraz po rozciągnięciu, histogram szarości tego obrazu}
\end{figure}

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Rozciąganie histogramu]
def stretch(self, show = False, plot = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	for i in range(height):
		for j in range(width):
			resultImage[i, j] = self.im[i, j]
	
	# wartosc min i max w obrazie
	maxValue = 0
	minValue = 255
	while maxValue != 255:
		# wartosci max i min w obrazie
		for i in range(height):
			for j in range(width):
				currValue = resultImage[i, j]
				maxValue = max(maxValue, currValue)
				minValue = min(minValue, currValue)
	
	# rozciaganie
	for i in range(height):
		for j in range(width):
			pix = resultImage[i, j]
			resultImage[i, j] = ((255 / (maxValue - minValue)) * (pix - minValue))
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "stretchHist")
\end{lstlisting}

\newpage





\section{Progowanie lokalne}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Progowanie lokalne oblicza wartość progową dla każdego piksla z osobna. Jest to jedna z metod binaryzacji obrazu, która w wyniku dokładniej odwzorowuje kształt obiektu na obrazie.
\begin{enumerate}
	\item Zdefiniuj wielkość otoczenia piksla (musi być nieparzysta, po to, aby mógł istnieć piksel środkowy).
	\item Dla każdego piskla:
	\item Oblicz wartość progową jako średnią wartość piksli w otoczeniu danego piksla.
	\item Jeśli wartość piksla środkowego jest $< 0$:
	\item Przypisz mu wartość $0$.
	\item W przeciwnym przypadku przypisz mu wartość $255$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.37\textwidth]{gentelman_gray}
		\includegraphics[width=0.37\textwidth]{gentelman_gray_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.37\textwidth]{gentelman_gray_locThreshold_result}
		\includegraphics[width=0.37\textwidth]{gentelman_gray_locThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu z parametrem 21, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{pirate_gray}
		\includegraphics[width=0.4\textwidth]{pirate_gray_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{pirate_gray_locThreshold_result}
		\includegraphics[width=0.4\textwidth]{pirate_gray_locThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu z parametrem 21, histogram szarości tego obrazu}
\end{figure}

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Progowanie lokalne]
def localThreshold(self, dim = 3, show = False, plot = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	l, r = -(int(round(dim / 2))), int(round(dim / 2) + 1)  # wsp. sasiadow
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	# progowanie lokalne
	for i in range(height):
		for j in range(width):
		n = 0
		threshold = 0
		currPix = self.im[i, j]
		for iOff in range(l, r):
			for jOff in range(l, r):
				iSafe = i if ((i + iOff) > (height + l)) else (i + iOff)
				jSafe = j if ((j + jOff) > (width + l)) else (j + jOff)
				threshold += self.im[iSafe, jSafe]
				n += 1
		threshold = int(round(threshold / n))
		resultImage[i, j] = 0 if (currPix < threshold) else 255
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "locThreshold")
\end{lstlisting}

\newpage
\clearpage




\section{Progowanie globalne}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Progowanie globalne jest jedną z metod binaryzacji obrazu. Wartość progowa jest ustalana globalnie biorąc pod uwagę wartość każdego piklsla w obrazie, po czym stosując wyliczony próg aby nadać nową wartość każdemu poikslowi. Obraz w wyniku jest binarny.
\begin{enumerate}
	\item Oblicz wartość progową $T$, jako średnią wartość z wszystkich piskli w obrazie
	\item Dla każdego piskla:
	\item Jeśli wartość danego piskla jest $< T$:
	\item przypisz mu wartość $0$.
	\item W przeciwnym przypadku przypisz mu wartość 255.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{gentelman_gray}
		\includegraphics[width=0.4\textwidth]{gentelman_gray_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{gentelman_gray_globThreshold_result}
		\includegraphics[width=0.4\textwidth]{gentelman_gray_globThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu globalnym, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{pirate_gray}
		\includegraphics[width=0.4\textwidth]{pirate_gray_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{pirate_gray_globThreshold_result}
		\includegraphics[width=0.4\textwidth]{pirate_gray_globThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu globalnym, histogram szarości tego obrazu}
\end{figure}

%\subsection*{Kod źródłowy}
\begin{lstlisting}[caption=Progowanie globalne]
def globalThreshold(self, show = False, plot = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	# prog globalny
	threshold = 0
	n = 0
	for i in range(height):
		for j in range(width):
		threshold += self.im[i, j]
		n += 1
		threshold = int(round(threshold / n))
	
	# binaryzacja
	for i in range(height):
		for j in range(width):
			resultImage[i, j] = 0 if (self.im[i, j] < threshold) else 255
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "globThreshold")
\end{lstlisting}
\newpage






\chapter{Operacje na histogramie obrazu barwowego}
Histogram to najprostszy opis całościowy obrazu. Dlatego stosuje się go, by rozpoznać, jakie dalsze metody i operacje należy zastosować na przetwarzanym obrazie, by osiągnać założony cel. Jego obliczenie polega na odczytaniu barwy każdego piksla i rejestrowaniu jej wystąpienia o danym poziomie.\\
Histogram to funkcja przypisująca każdemu poziomowi barwy obrazu, liczbę piksli z danym poziomem barwy, czyli jest to wykres częstości występowania wartości piksli w obrazie.
\newpage

\section{Obliczanie histogramu}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Histogram obrazu barwnego jest wykresem częstości występowania wartości barwy piksli w obrazie tj.
przyporządkowuje liczbę piskli do danego poziomu barwy.\newline
\begin{enumerate}
	\item Zaalokuj 3 tablice 256 elementowe (tyle, ile poziomów barw w obrazie)
	\item Dla każdego piskla:
	\item Dla każdej barwy:
	\item Zinkrementuj element tablicy danej barwy o indeksie równym poziomie tej barwy danego piskla
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{lena_color}
		\includegraphics[width=0.4\textwidth]{lena_color_histogram}
	\end{center}
	\caption{Obraz barwny, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{peppers_color}
		\includegraphics[width=0.4\textwidth]{peppers_color_histogram}
	\end{center}
	\caption{Obraz barwny, histogram barw tego obrazu}
\end{figure}
\pagebreak

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Obliczanie histogramu]
def calculate(self, plot = False, image = None):
	if image is None:
	image = self.im
	
	width = image.shape[1]      # szerokosc
	height = image.shape[0]     # wysokosc
	hist = [0] * 3              # histogram RGB
	hist[0] = [0] * 256         # histogram R
	hist[1] = [0] * 256         # histogram G
	hist[2] = [0] * 256         # histogram B
	
	for i in range(height):
		for j in range(width):
		bin = image[i, j]
		for k in range(3):
			hist[k][bin[k]] += 1
	
	if plot:
		# tablica [0, 1, ... , 254, 255]
		bins = np.arange(256)
		self.plotHistogram(bins, hist)
	
	return hist                 # [0] - hist R, [1] - hist G, [2] - hist B
\end{lstlisting}

\pagebreak


\section{Przemieszczanie histogramu}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Przemieszczenie histogramu polega na dodaniu lub odjęciu tej samej wartości od poziomu każdej z barw każdego piksla w obrazie.
W rezultacie obraz jest odpowiednio równomiernie rozjaśniony bądź przyciemniony.
Nie można przekroczyć przyjętego zakresu poziomu barwy.
\begin{enumerate}
	\item Do każdej wartości barwy piksla dodaj podaną stałą, o którą chcesz przemieścić histogram.
	\item Jeśli wartość barwy piksla po operacji dodawania wykracza poza zakres 255:
	\item Przypisz jej wartość 255.
	\item Jeśli wartość piksla po operacji dodawania jest mniejsza od 0:
	\item Przypisz jej wartość 0.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color_moveHist_result}
		\includegraphics[width=0.35\textwidth]{lena_color_moveHist_histogram}
	\end{center}
	\caption{Obraz wyjściowy przesunięty o 50, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color_moveHist_result}
		\includegraphics[width=0.35\textwidth]{peppers_color_moveHist_histogram}
	\end{center}
	\caption{Obraz wyjściowy przesunięty o -50, histogram barw tego obrazu}
\end{figure}


%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Przemieszczanie histogramu]
def move(self, const = 0, show = False, plot = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	
	# przemieszczanie
	for i in range(height):
		for j in range(width):
			value = self.im[i, j]
			for k in range(len(value)):
				v = value[k]
				v += const
				if v < 0:
					v = 0
				elif v > 255:
					v = 255
				value[k] = v
			resultImage[i, j] = value
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "moveHist")
\end{lstlisting}

\newpage

\section{Rozciąganie histogramu}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent  Rozciągania histogramu dokonuje się na obrazie, którego poziomy barw nie są rozpięte na cały możliwy zakres np.
[51, 233]. Operacja rozciągnięcia histogramu rozciągnie histogram tak, aby był rozpięty na cały możliwy zakres poziomów barw np. [0, 255].
\begin{enumerate}
	\item Znajdź w obrazie największą($max_c$) i najmniejszą($min_c$) wartość piksla dla każdej z barw($c$)
	\item Dla każdego piksla($P_o$):
	\item Dla każdej z barw($c$):
	\item Oblicz nową wartość piskla($P_n$) stosując wzór:\\
	\centerline{$P_n = 255$ $//$ $(max_c - min_c) * (P_o - min_c)$.}
	W taki sposób, jeśli barwy obrazu wejściowego były w zakresie
	np. $[12, 239]$, po operacji rozciągania histogramu, będą w zakresie $[0, 255]$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color_stretchHist_result}
		\includegraphics[width=0.35\textwidth]{lena_color_stretchHist_histogram}
	\end{center}
	\caption{Obraz po rozciągnięciu, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color_stretchHist_result}
		\includegraphics[width=0.35\textwidth]{peppers_color_stretchHist_histogram}
	\end{center}
	\caption{Obraz po rozciągnięciu, histogram barw tego obrazu}
\end{figure}

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Rozciąganie histogramu]
def stretch(self, show = False, plot = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	for i in range(height):
		for j in range(width):
			resultImage[i, j] = self.im[i, j]
	
	# wartosci min i max w obrazie
	maxValue = [0] * 3
	minValue = [255] * 3
	while (maxValue[0] != 255) & (maxValue[1] != 255) & (maxValue[2] != 255):
		# wartosci max i min w obrazie
		for i in range(height):
			for j in range(width):
				currValue = resultImage[i, j]
				for k in range(3):
					maxValue[k] = max(maxValue[k], currValue[k])
					minValue[k] = min(minValue[k], currValue[k])
	
	# rozciaganie
	for i in range(height):
		for j in range(width):
			pix = resultImage[i, j]
			for k in range(3):
				pix[k] = ((255 / (maxValue[k] - minValue[k])) * (pix[k] - minValue[k]))
			resultImage[i, j] = pix
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "stretchHist")
\end{lstlisting}

\newpage



\section{Progowanie 1-progowe lokalne}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Progowanie 1-progowe lokalne oblicza wartość progową dla każdego piksla z osobna. W wyniku takiego progowania obraz dokładniej odwzorowuje kształt obiektu. Próg obliczany jest jako średnia wartość piksli w obrazie, dla każdego kanału z osobna.
\begin{enumerate}
	\item Zdefiniuj wielkość otoczenia piksla (musi być nieparzysta, po to, aby mógł istnieć piksel środkowy).
	\item Dla każdego piskla($P$):
	\item Dla każdego kanału($C$):
	\item Oblicz wartość progową $T_C$ jako średnią wartość piksli $P_C$ w otoczeniu danego piksla($P$).
	\item Jeśli wartość piksla $P_C$ jest $< T_C$:
	\item Przypisz mu wartość $0$.
	\item W przeciwnym przypadku przypisz mu wartość $255$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color_localSingleThreshold_result}
		\includegraphics[width=0.35\textwidth]{lena_color_localSingleThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu z otoczeniem piksla 21x21, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram szarości tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color_localSingleThreshold_result}
		\includegraphics[width=0.35\textwidth]{peppers_color_localSingleThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu z otoczeniem piksla 21x21, histogram szarości tego obrazu}
\end{figure}

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Progowanie 1-progowe lokalne]
def localSingleThreshold(self, dim = 3, show = False, plot = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	low, up = -(int(dim / 2)), (int(dim / 2) + 1)  # wsp. sasiadow
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	tmp = np.empty((height, width, 3))
	tmp2 = np.empty((height, width, 3))
	
	# progowanie lokalne
	for i in range(height):
		for j in range(width):
			n = 0
			r = 0
			g = 0
			b = 0
			currPix = self.im[i, j]
			for iOff in range(low, up):
				for jOff in range(low, up):
					iSafe = i if ((i + iOff) > (height + low)) | ((i + iOff) < 0) else (i + iOff)
					jSafe = j if ((j + jOff) > (width + low)) | ((j + jOff) < 0) else (j + jOff)
					r += int(self.im[iSafe, jSafe][0])
					g += int(self.im[iSafe, jSafe][1])
					b += int(self.im[iSafe, jSafe][2])
					n += 1
			r = int(round(r / n))
			g = int(round(g / n))
			b = int(round(b / n))
			resultImage[i, j] = (0 if (currPix[0] < r) else 255, 0 if (currPix[1] < g) else 255, 0 if (currPix[2] < b) else 255)
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "localSingleThreshold")
\end{lstlisting}

\newpage




\section{Progowanie wielo-progowe lokalne}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Progowanie wielo-progowe lokalne oblicza wartości progowe dla każdego piksla z osobna. W wyniku takiego progowania obraz ma mniejszą ilość kolorów w obrazie. Progi obliczane są dla każdego kanału z osobna.

\begin{enumerate}
	\item Zdefiniuj wielkość otoczenia piksla (musi być nieparzysta, po to aby mógł istnieć piksel środkowy).
	\item Zdefiniuj ilość progów($T$).
	\item Dla każdego piksla($P$):
	\item Dla każdego kanału($C$):
	\item Znajdź $MAX(P_C)$ i $MIN(P_C)$.
	\item Oblicz skalę($S_C$) wg. wzoru:\\
	\centerline{$S_C = \frac{MAX(P_C)}{(T - 1)}$.}
	\item Jeśli $S_C = 0$:
	\item Przypisz $S_C$ wartość 1 (aby uniknąć dzielenia przez 0).
	\item Wylicz nową wartość piksla($P_{C_{n}}$) wg. wzoru:\\
	\centerline{$P_{C_{n}} = \lceil \frac{P_C}{S_C} \rceil * S_C $.}
\end{enumerate}


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color_localMultiThreshold_result}
		\includegraphics[width=0.35\textwidth]{lena_color_localMultiThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu lokalnym (okno 21x21, progi 4), histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color_localMultiThreshold_result}
		\includegraphics[width=0.35\textwidth]{peppers_color_localMultiThreshold_histogram}
	\end{center}
\caption{Obraz po progowaniu lokalnym (okno 21x21, progi 4), histogram barw tego obrazu}
\end{figure}


%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Progowanie wielo-progowe lokalne]
def localMultiThreshold(self, dim=3, bins=4, show=False, plot=False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	low, up = -(int(dim / 2)), (int(dim / 2) + 1)  # wsp. sasiadow
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	
	# progowanie lokalne
	for i in range(height):
		for j in range(width):
			n = 0
			r = 0
			g = 0
			b = 0
			currPix = self.im[i, j]
			maxValue = [0] * 3
			minValue = [255] * 3
			for iOff in range(low, up):
				for jOff in range(low, up):
					iSafe = i if ((i + iOff) > (height + low)) | ((i + iOff) < 0) else (i + iOff)
					jSafe = j if ((j + jOff) > (width + low)) | ((j + jOff) < 0) else (j + jOff)
					currValue = self.im[iSafe, jSafe]
					for k in range(3):
						maxValue[k] = max(maxValue[k], currValue[k])
						minValue[k] = min(minValue[k], currValue[k])
			scale = [0] * 3
			for k in range(3):
				scale[k] = maxValue[k] / (bins - 1)
				if scale[k] == 0:
					scale[k] = 1
			for k in range(3):
				v = int(round(currPix[k] / scale[k])) * scale[k]
				currPix[k] = v
			resultImage[i, j] = currPix
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "localMultiThreshold")
\end{lstlisting}

\newpage




\section{Progowanie 1-progowe globalne}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent W progowaniu 1-progowym globalnym wartość progowa jest ustalana globalnie dla każdego kanału z osobna, biorąc pod uwagę wartość każdego piklsla w obrazie. Następnie, tak wyliczona wartość progowa, jest stosowana do nadania każdemu pikslowi nową wartość.
\begin{enumerate}
	\item Dla każdego kanału($C$):
	\item Oblicz wartość progową $T_C$, jako średnią wartość z wszystkich piskli $P_C$ w obrazie.
	\item Dla każdego piskla($P$):
	\item Dla każdego kanału($C$):
	\item Jeśli wartość $P_C$ danego piskla jest $< T_C$:
	\item przypisz mu wartość $0$.
	\item W przeciwnym przypadku przypisz mu wartość 255.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color_globalSingleThreshold_result}
		\includegraphics[width=0.35\textwidth]{lena_color_globalSingleThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu 1-progowym globalnym, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color_globalSingleThreshold_result}
		\includegraphics[width=0.35\textwidth]{peppers_color_globalSingleThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu 1-progowym globalnym, histogram barw tego obrazu}
\end{figure}

%\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Progowanie 1-progowe globalne]
def globalSingleThreshold(self, show = False, plot = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	tmp = np.empty((height, width, 3))
	tmp2 = np.empty((height, width, 3))
	
	# prog globalny
	globalR = 0
	globalG = 0
	globalB = 0
	nR = 0
	nG = 0
	nB = 0
	for i in range(height):
		for j in range(width):
			globalR += self.im[i, j][0]
			nR += 1
			globalG += self.im[i, j][1]
			nG += 1
			globalB += self.im[i, j][2]
			nB += 1
	globalR = int(round(globalR / nR))
	globalG = int(round(globalG / nG))
	globalB = int(round(globalB / nB))
	
	# kwantzyacja
	for i in range(height):
		for j in range(width):
			resultImage[i, j] = (0 if (self.im[i, j][0] < globalR) else 255, 0 if (self.im[i, j][1] < globalG) else 255, 0 if (self.im[i, j][2] < globalB) else 255)
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "globalSingleThreshold")
\end{lstlisting}

\newpage




\section{Progowanie wielo-progowe globalne}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent W progowaniu wielo-progowym globalnym wartości progowe są ustalane dla każdego kanału z osobna, biorąc pod uwagę wartość każdego piksla w obrazie. Następnie, tak wyliczona wartość progowa, jest stosowana do nadania każdemu pikslowi nowej wartości.

\begin{enumerate}
	\item Zdefiniuj ilość progów($T$).
	\item Dla każdego piksla($P$):
	\item Dla każdego kanału($C$):
	\item Znajdź $MAX(P_C)$ i $MIN(P_C)$.
	\item Oblicz skalę($S_C$) wg. wzoru:\\
	\centerline{$S_C = \frac{MAX(P_C)}{(T - 1)}$.}
	\item Dla każdego piskla($P$):
	\item Dla każdego kanału($C$):
	\item Wylicz nową wartość piksla($P_{C_{n}}$) wg. wzoru:\\
	\centerline{$P_{C_{n}} = \lceil \frac{P_C}{S_C} \rceil * S_C $.}
\end{enumerate}




\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color_globalMultiThreshold_result}
		\includegraphics[width=0.35\textwidth]{lena_color_globalMultiThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu wielo-progowym globalnym (progi 4), histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_histogram}
	\end{center}
	\caption{Obraz wejściowy, histogram barw tego obrazu}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color_globalMultiThreshold_result}
		\includegraphics[width=0.35\textwidth]{peppers_color_globalMultiThreshold_histogram}
	\end{center}
	\caption{Obraz po progowaniu wielo-progowym globalnym (progi 4), histogram barw tego obrazu}
\end{figure}




%\subsection*{Kod źródłowy}
\begin{lstlisting}[caption=Progowanie wielo-progowe globalne]
	
def globalMultiThreshold(self, bins = 4, show = False, plot = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	
	maxValue = [0] * 3
	minValue = [255] * 3
	# wartosci max i min w obrazie
	for i in range(height):
		for j in range(width):
			currValue = self.im[i, j]
			for k in range(3):
				maxValue[k] = max(maxValue[k], currValue[k])
				minValue[k] = min(minValue[k], currValue[k])
	
	scale = [0] * 3
	for k in range(3):
	scale[k] = maxValue[k] / (bins - 1)
	
	for i in range(height):
		for j in range(width):
			pix = self.im[i, j]
			for k in range(3):
				pix[k] = int(round(pix[k] / scale[k])) * scale[k]
			resultImage[i, j] = pix
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.calculate(plot, resultImage)
	self.save(resultImage, self.imName, "globalMultiThreshold")
	
\end{lstlisting}

\newpage

\chapter{Operacje morfologiczne na obrazach binarnych}

W obrazie binarnym piksele mogą przybierać tylko dwie wartości. Zazwyczaj kodowane są za pomocą pojedynczego bitu i przyjmują wartość 0 lub 1. Spotyka się także reprezentacje wykorzystujące inne pary wartości: (0, 255), (-1, 1), (True, False). \\
W przedstawionych przykładach została użyta reprezentacja (0,255), gdzie 0 oznacza czerń a 255 biały.

W morfologicznym przetwarzaniu obrazów ważne jest określenie, kiedy dwa piksele sąsiadują ze sobą. W tym celu definiuje się dla każdego piksla jego sąsiedztwo. Przy implementacji wykorzystano sąsiedztwo czterospójne: 

	Sąsiedztwo czterospójne (von Neumanna) - obejmuje cztery piksele przyległe do danego z góry, dołu i po bokach
	\begin{center}
	 $N_{4}(p)=((x,y-1),(x,y+1),(x-1,y),(x+1,y))$
	 \end{center}

\section{ Okrawanie (erozja)}
\hfill\\
\indent
       Przyjeto, ze wartosci wykraczajace poza granice (wysokość/szerokość) obrazu są białe (maja wartość 255)\\
	\begin{enumerate}	
		\item Dla wszystkich pikseli wykonaj:
		\item Wczytaj wartości sąsiadujących pikseli $(x,y-1),(x,y+1),(x-1,y),(x+1,y)$ od piksla $(x,y)$.
		\item Jeżeli którykolwiek z sąsiadów ma wartość równą 255 to środkowy piksel $(x,y)$ ma przyjąć wartość 255. 
		\item Jeżeli wszyscy sąsiedzi mają wartość równą 0 to środkowy piksel $(x,y)$ ma przyjąć wartość 0.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Bin_E_Original}
		\includegraphics[width=0.3\textwidth]{1/1Bin_E_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po operacji okrawania (erozji) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Bin_E_Original}
		\includegraphics[width=0.3\textwidth]{2/2Bin_E_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po operacji okrawania (erozji) }
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja okrawania (erozji) na obrazie binarnym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((height, width), dtype=np.uint8)

for y in range(height):
    for x in range(width):  
        # Przyjeto, ze wartosci wykraczajace poza granice obrazu sa biale (maja wartosc 255)
        neighbour_pix = [255, 255, 255, 255]

        if x - 1 > 0:
                neighbour_pix[0]=(image_matrix[y][x-1][0])
        if y - 1 > 0:
                neighbour_pix[1]=(image_matrix[y-1][x][0])
        if x + 1 < width:
                neighbour_pix[2]=(image_matrix[y][x+1][0])
        if y + 1 < height:
                neighbour_pix[3]=(image_matrix[y+1][x][0])

        if 255 in neighbour_pix:
                result_matrix[y][x] = 255 #bialy
        else:
                result_matrix[y][x] = 0 #czarny   

\end{lstlisting}
\newpage

\section{ Nakładanie (dylatacja)}
\hfill\\
\indent
       Przyjeto, ze wartosci wykraczajace poza granice (wysokość/szerokość) obrazu są białe (maja wartość 255)\\
	\begin{enumerate}	
		\item Dla wszystkich pikseli wykonaj:
		\item Wczytaj wartości sąsiadujących pikseli $(x,y-1),(x,y+1),(x-1,y),(x+1,y)$ od piksla $(x,y)$.
		\item Jeżeli którykolwiek z sąsiadów ma wartość równą 0 to środkowy piksel $(x,y)$ ma przyjąć wartość 0. 
		\item Jeżeli wszyscy sąsiedzi mają wartość równą 255 to środkowy piksel $(x,y)$ ma przyjąć wartość 255.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Bin_D_Original}
		\includegraphics[width=0.3\textwidth]{1/1Bin_D_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po operacji nakładania (dylatacji) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Bin_D_Original}
		\includegraphics[width=0.3\textwidth]{2/2Bin_D_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po operacji nakładania (dylatacji)}
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja nakładania (dylatacji) na obrazie binarnym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((height, width), dtype=np.uint8)

for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(image_matrix[y][x-1][0])
                if y - 1 > 0:
                        neighbour_pix[1]=(image_matrix[y-1][x][0])
                if x + 1 < width:
                        neighbour_pix[2]=(image_matrix[y][x+1][0])
                if y + 1 < height:
                        neighbour_pix[3]=(image_matrix[y+1][x][0])

                if 0 in neighbour_pix:
                        result_matrix[y][x] = 0
                else:
                        result_matrix[y][x] = 255          

\end{lstlisting}
\newpage

\section{ Otwarcie}
.\hfill\\
\indent
	Otwarcie morfologiczne jest równoważne nałożeniu operacji dylatacji na wynik erozji obrazu pierwotnego.

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Op_Original}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Op_E_Result}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Op_ED_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po dylacji, obraz po operacji otwarcia (erozja $\rightarrow$ dylatacja)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Op_Original}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Op_E_Result}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Op_ED_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po dylacji, obraz po operacji otwarcia (erozja $\rightarrow$ dylatacja)}
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja otwarcia na obrazie binarnym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

e_result_matrix = np.zeros((height, width), dtype=np.uint8)
d_result_matrix = np.zeros((height, width), dtype=np.uint8)

#erozja
for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(image_matrix[y][x-1][0])
                if y - 1 > 0:
                        neighbour_pix[1]=(image_matrix[y-1][x][0])
                if x + 1 < width:
                        neighbour_pix[2]=(image_matrix[y][x+1][0])
                if y + 1 < height:
                        neighbour_pix[3]=(image_matrix[y+1][x][0])

                if 255 in neighbour_pix:
                        e_result_matrix[y][x] = 255
                else:
                        e_result_matrix[y][x] = 0 

Image.fromarray(e_result_matrix).show()
#dylatacja
for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(e_result_matrix[y][x-1])
                if y - 1 > 0:
                        neighbour_pix[1]=(e_result_matrix[y-1][x])
                if x + 1 < width:
                        neighbour_pix[2]=(e_result_matrix[y][x+1])
                if y + 1 < height:
                        neighbour_pix[3]=(e_result_matrix[y+1][x])

                if 0 in neighbour_pix:
                        d_result_matrix[y][x] = 0
                else:
                        d_result_matrix[y][x] = 255   

\end{lstlisting}
\newpage

\section{ Zamknięcie}
.
.\hfill\\
\indent
	Zamknięcie morfologiczne jest równoważne nałożeniu operacji erozji na wynik dylatacji obrazu pierwotnego.

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Cl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Cl_D_Result}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Cl_DE_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po erozji, obraz po operacji zamknięcia (dylatacja $\rightarrow$ erozja)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Cl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Cl_D_Result}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Cl_DE_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po erozji, obraz po operacji zamknięcia (dylatacja $\rightarrow$ erozja)}
\end{figure}


\subsection*{Kod źródłowy}
.

\begin{lstlisting}[caption= Operacja zamknięcia na obrazie binarnym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

e_result_matrix = np.zeros((height, width), dtype=np.uint8)
d_result_matrix = np.zeros((height, width), dtype=np.uint8)

#dylatacja
for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(image_matrix[y][x-1][0])
                if y - 1 > 0:
                        neighbour_pix[1]=(image_matrix[y-1][x][0])
                if x + 1 < width:
                        neighbour_pix[2]=(image_matrix[y][x+1][0])
                if y + 1 < height:
                        neighbour_pix[3]=(image_matrix[y+1][x][0])

                if 0 in neighbour_pix:
                        d_result_matrix[y][x] = 0
                else:
                        d_result_matrix[y][x] = 255

Image.fromarray(e_result_matrix).show()

#erozja
for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(d_result_matrix[y][x-1])
                if y - 1 > 0:
                        neighbour_pix[1]=(d_result_matrix[y-1][x])
                if x + 1 < width:
                        neighbour_pix[2]=(d_result_matrix[y][x+1])
                if y + 1 < height:
                        neighbour_pix[3]=(d_result_matrix[y+1][x])

                if 255 in neighbour_pix:
                        e_result_matrix[y][x] = 255
                else:
                        e_result_matrix[y][x] = 0         

\end{lstlisting}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%SZARE

\chapter {Operacje morfologiczne na obrazach szarych}
.\hfill\\
\indent
W morfologicznym przetwarzaniu obrazów ważne jest określenie, kiedy dwa piksele sąsiadują ze sobą. W tym celu definiuje się dla każdego piksla jego sąsiedztwo. Przy implementacji wykorzystano sąsiedztwo czterospójne: 

	Sąsiedztwo czterospójne (von Neumanna) - obejmuje cztery piksele przyległe do danego z góry, dołu i po bokach
	\begin{center}
	 $N_{4}(p)=((x,y-1),(x,y+1),(x-1,y),(x+1,y))$
	 \end{center}

\section{ Okrawanie (erozja)}
.\hfill\\
\indent
\begin{enumerate}	
		\item Dla wszystkich pikseli wykonaj:
		\item Wczytaj wartości sąsiadujących pikseli do wektora $(x,y-1),(x,y+1),(x-1,y),(x+1,y)$ od piksela $(x,y)$.
		\item Posortuj wektor.
		\item Przypisz wartość piksela o najniższej jasnosci do piksela $(x,y)$.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_E_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_E_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (256x256), obraz (256x256) po operacji okrawania (erozji) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_E_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_E_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz (512x512) po operacji okrawania (erozji) }
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja okrawania (erozji) na obrazie szarym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((height, width), dtype=np.uint8)

for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(image_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(image_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(image_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(image_matrix[y+1][x])

            min_pix = min(neighbour_pix)
            result_matrix[y][x] = min_pix

\end{lstlisting}
\newpage

\section{ Nakładanie (dylatacja)}
.\hfill\\
\indent
\begin{enumerate}	
		\item Dla wszystkich pikseli wykonaj:
		\item Wczytaj wartości sąsiadujących pikseli do wektora $(x,y-1),(x,y+1),(x-1,y),(x+1,y)$ od piksela $(x,y)$.
		\item Posortuj wektor.
		\item Przypisz wartość piksela o najwyższej jasnosci do piksela $(x,y)$.
	\end{enumerate}
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_D_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_D_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (256x256), obraz (256x256) po operacji nakładania (dylatacji) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_D_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_D_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz (512x512) po operacji nakładania (dylatacji)}
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja nakładania (dylatacji) na obrazie szarym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((height, width), dtype=np.uint8)
print(image_matrix)
print(result_matrix)

for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(image_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(image_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(image_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(image_matrix[y+1][x])

            max_pix = max(neighbour_pix)
            result_matrix[y][x] = max_pix      


\end{lstlisting}
\newpage

\section{ Otwarcie}
.\hfill\\
\indent
	Otwarcie morfologiczne jest równoważne nałożeniu operacji dylatacji na wynik erozji obrazu pierwotnego.

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Op_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Op_E_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Op_ED_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (256x256), obraz po dylacji, obraz po operacji otwarcia (erozja $\rightarrow$ dylatacja)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Op_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Op_E_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Op_ED_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz po dylacji, obraz po operacji otwarcia (erozja $\rightarrow$ dylatacja)}
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja otwarcia na obrazie szarym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

e_result_matrix = np.zeros((height, width), dtype=np.uint8)
d_result_matrix = np.zeros((height, width), dtype=np.uint8)

#erozja
for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(image_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(image_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(image_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(image_matrix[y+1][x])

            min_pix = min(neighbour_pix)
            e_result_matrix[y][x] = min_pix

Image.fromarray(e_result_matrix).show()
#dylatacja
for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(e_result_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(e_result_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(e_result_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(e_result_matrix[y+1][x])

            max_pix = max(neighbour_pix)
            d_result_matrix[y][x] = max_pix    

\end{lstlisting}
\newpage

\section{ Zamknięcie}
.\hfill\\
\indent
	Zamknięcie morfologiczne jest równoważne nałożeniu operacji erozji na wynik dylatacji obrazu pierwotnego.

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Cl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Cl_D_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Cl_DE_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (256x256), obraz po erozji, obraz po operacji zamknięcia (dylatacja $\rightarrow$ erozja)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Cl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Cl_D_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Cl_DE_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz po erozji, obraz  po operacji zamknięcia (dylatacja $\rightarrow$ erozja)}
\end{figure}


\subsection*{Kod źródłowy}
.

\begin{lstlisting}[caption= Operacja zamknięcia na obrazie szarym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

e_result_matrix = np.zeros((height, width), dtype=np.uint8)
d_result_matrix = np.zeros((height, width), dtype=np.uint8)

#dylatacja
for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(image_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(image_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(image_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(image_matrix[y+1][x])

            max_pix = max(neighbour_pix)
            d_result_matrix[y][x] = max_pix   


#erozja
for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(d_result_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(d_result_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(d_result_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(d_result_matrix[y+1][x])

            min_pix = min(neighbour_pix)
            e_result_matrix[y][x] = min_pix     

\end{lstlisting}
\newpage


\chapter {Filtrowanie liniowe i nieliniowe}
Filtrowanie obrazów oznacza, że do obliczenia nowej wartości danego piksela brane są pod uwagę wartości pikseli z jego otoczenia. Każdy punkt z otoczenia wnosi swój wkład (wagę) podczas przeprowadzania końcowych obliczeń. Wagi te są zapisywane w postaci maski. Najczęściej spotykane rozmiary filtrów to maski o rozmiarach 3x3, 5x5. Ale filtry o rozmiarach 7x7, 9x9 również są nierzadko używane. Filtrowanie odbywa się w ten sposób, że maskę przemieszcza się w obrębie obrazu z krokiem równym odległości międzypikslowej. Poniżej przykład dla maski o wymiarach 3x3:

\begin{center}
	\begin{tabular}{ c c c }
		$f_{-1,-1}$ & $f_{0,-1}$ & $f_{1,-1}$ \\
		$f_{-1, 0}$ & $f_{0, 0}$ & $f_{1, 0}$ \\
		$f_{-1, 1}$ & $f_{0, 1}$ & $f_{1, 1}$    
	\end{tabular}
\end{center}

By obliczyć nową wartość piksla należy wpierw obliczyć sumę ważoną składowych punktu oraz wszystkich sąsiadujących punktów zgodnie z wagami wskazanymi przez maskę.

\begin{center}
	$s = f_{-1,-1} * a_{i-1,j-1} + f_{0,-1} * a_{i,j-1} + f_{1,-1} * a_{i+1,j-1} + f_{-1,0} * a_{i-1,j} + f_{0,0} * a_{i,j} + f_{1,0} * a_{i+1,j} + f_{-1,1} * a_{i-1,j+1} + f_{0,1} * a_{i,j+1} + f_{1,1} * a_{i+1,j+1}$
\end{center}

Otrzymaną sumę dzielimy przez sumę wszystkich wag maski, jeżeli jest ona różna od 0.

\begin{center}
	$a'_{i,j} = \frac{s}{f_{-1,-1} + f_{0,-1} + f_{1,-1} + f_{-1,0} + f_{0,0} + f_{1,0} + f_{-1,1} + f_{0,1} + f_{1,1}}$
\end{center}

\newpage


\section{Filtr dolnoprzepustowy uśredniający}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Filtr uśredniający jest podstawowym filtrem dolnoprzepustowym, jego wynikiem jest uśrednienie każdego piksla razem ze swoimi sąsiadami. Maska:
\begin{center}
	$\frac{1}{9}$ 
	\begin{tabular}{|c|c|c|}
		\hline
		1 & 1 & 1\\
		\hline
		1 & 1 & 1\\
		\hline
		1 & 1 & 1\\
		\hline
	\end{tabular}
\end{center}

\begin{enumerate}
	\item Dla każdego piksla($P$):
	\item Dla każdej barwy:
	\item Zsumuj wartości barwy piksli, otaczających piksel $P$ pomnożonych przez odpowiednią wagę maski.
	\item Sumę barwy podziel przez sumę wag maski.
	\item Przypisz nową wartość barwy pikslowi $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_lowpassAvg_result}
	\end{center}
	\caption{Obraz wejściowy, obraz uśredniony}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_lowpassAvg_result}
	\end{center}
	\caption{Obraz wejściowy, obraz uśredniony}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_lowpassAvg_result}
	\end{center}
	\caption{Obraz wejściowy, obraz uśredniony}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_lowpassAvg_result}
	\end{center}
	\caption{Obraz wejściowy, obraz uśredniony}
\end{figure}
\newpage




%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Filtr dolnoprzepustowy uśredniający (obraz szary)]

def averageGray(self, show = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)

	mask = np.ones((3, 3))      
	
	# wygladzanie
	for i in range(height):
		for j in range(width):
			avg = 0
			n = 0
			for iOff in range(-1, 1):
				for jOff in range(-1, 1):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					avg += self.im[iSafe, jSafe] * mask[iOff + 1, jOff + 1]
					n += mask[iOff + 1, jOff + 1]
		avg = int(round(avg / n))
		resultImage[i, j] = avg
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "lowpassAvg")

\end{lstlisting}

\newpage


%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Filtr dolnoprzepustowy uśredniający (obraz barwny)]
	
def averageColor(self, show = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)

	mask = np.ones((3, 3))      

	# wygladzanie
	for i in range(height):
		for j in range(width):
			avgr = 0
			avgg = 0
			avgb = 0
			n = 0
			for iOff in range(-1, 1):
				for jOff in range(-1, 1):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					avgr += self.im[iSafe, jSafe][0] * mask[iOff + 1, jOff + 1]
					avgg += self.im[iSafe, jSafe][1] * mask[iOff + 1, jOff + 1]
					avgb += self.im[iSafe, jSafe][2] * mask[iOff + 1, jOff + 1]
					n += mask[iOff + 1, jOff + 1]
			avgr = int(round(avgr / n))
			avgg = int(round(avgg / n))
			avgb = int(round(avgb / n))
			resultImage[i, j] = (avgr, avgg, avgb)
			
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "lowpassAvg")
	
\end{lstlisting}

\newpage



\section{Filtr dolnoprzepustowy Gaussowski}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Filtr Gaussa jest filtrem uśredniającym. Jego maska aproksymuje 2-wymiarową krzywą Gaussa. W odrużnieniu od filtru uśredniającego efekt rozmycia przez ten filtr jest mniejszy. Maska:
\begin{center}
	$\frac{1}{47}$ 
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		1 & 1 & 1 & 1 & 1\\
		\hline
		1 & 4 & 6 & 4 & 1\\
		\hline
		1 & 1 & 1 & 1 & 1\\
		\hline
		1 & 4 & 6 & 4 & 1\\
		\hline
		1 & 1 & 1 & 1 & 1\\
		\hline
	\end{tabular}
\end{center}

\begin{enumerate}
	\item Dla każdego piksla($P$):
	\item Dla każdej barwy:
	\item Zsumuj wartości barwy piksli, otaczających piksel $P$ pomnożonych przez odpowiednią wagę maski.
	\item Sumę wartości barwy podziel przez sumę wag maski.
	\item Przypisz nową wartość barwy pikslowi $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_lowpassGauss_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Gaussa}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_lowpassGauss_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Gaussa}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_lowpassGauss_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Gaussa}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_lowpassGauss_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Gaussa}
\end{figure}
\newpage

%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Filtr dolnoprzepustowy Gaussowski (obraz szary)]
	
def gaussGray(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	mask = np.ones((5, 5))
	mask[1, 1] = mask[3, 3] = mask[1, 3] = mask[3, 1] = 4
	mask[1, 2] = mask[3, 2] = 6
	
	# filtracja
	for i in range(height):
		for j in range(width):
			n = 0
			value = 0
			for iOff in range(-2, 3):
				for jOff in range(-2, 3):
					iSafe = i if ((i + iOff) > (height - 2)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 2)) else (j + jOff)
					value += self.im[iSafe, jSafe] * mask[iOff + 2, jOff + 2]
					n += mask[iOff + 2, jOff + 2]
			value = int(round(value / n))
			resultImage[i, j] = value
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "lowpassGauss")
	
\end{lstlisting}

\newpage

%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Filtr dolnoprzepustowy Gaussowski (obraz barwny)]

def gaussColor(self, show = False):
	width = self.im.shape[1]    # szereoksc
	height = self.im.shape[0]   # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	
	mask = np.ones((5, 5))
	mask[1, 1] = mask[3, 3] = mask[1, 3] = mask[3, 1] = 4
	mask[1, 2] = mask[3, 2] = 6

	# filtracja
	for i in range(height):
		for j in range(width):
			n = 0
			r, g, b = 0, 0, 0
			for iOff in range(-2, 3):
				for jOff in range(-2, 3):
					iSafe = i if ((i + iOff) > (height - 2)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 2)) else (j + jOff)
					r += self.im[iSafe, jSafe][0] * mask[iOff + 2, jOff + 2]
					g += self.im[iSafe, jSafe][1] * mask[iOff + 2, jOff + 2]
					b += self.im[iSafe, jSafe][2] * mask[iOff + 2, jOff + 2]
					n += mask[iOff + 2, jOff + 2]
			r = int(round(r / n))
			g = int(round(g / n))
			b = int(round(b / n))
			resultImage[i, j] = (r, g, b)
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "lowpassGauss")

\end{lstlisting}

\newpage



\section{Operator Roberts'a}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Filtr Roberts'a jest jednym z najbardziej znanych filtrów do wykrywania krawędzi w obrazie. Wynikowa wartość składowej po zastosowaniu owego filtra może wyjść ujemna, aby temu zapobiec należy użyć wartości bezwzględnej. Filtr Roberts'a jest bardzo wrażliwy na szum i ma niski poziom reakcji na krawędź obrazu. Maska:
\begin{center}
	\begin{tabular}{|c|c|c|}
		\hline
		0 & 0 & 0\\
		\hline
		0 & 0 & -1\\
		\hline
		0 & 1 & 0\\
		\hline
	\end{tabular}
\end{center}

\begin{enumerate}
	\item Dla każdego piksla($P$):
	\item Dla każdego kanału($C$):
	\item Zsumuj wartości piksli $P_C$, otaczających piksel $P$ pomnożonych przez odpowiednią wagę maski.
	\item Zastosój wartość bezwzględną na otrzymanej sumie.
	\item Przypisz nową wartość barwy pikslowi $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_highpassRoberts_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Roberts'a}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_highpassRoberts_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Roberts'a}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_highpassRoberts_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Roberts'a}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_highpassRoberts_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Roberts'a}
\end{figure}
\newpage

%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Operator Roberts'a (obraz szary)]
	
def robertsGray(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	mask = np.zeros((3, 3))
	mask[2, 1] = 1
	mask[1, 2] = -1
	
	# filtracja
	for i in range(height):
		for j in range(width):
			value = 0
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					value += self.im[iSafe, jSafe] * mask[iOff + 1, jOff + 1]
			resultImage[i, j] = abs(value)
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "highpassRoberts")
	
\end{lstlisting}


\newpage
%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Operator Roberts'a (obraz barwny)]
	
def robertsColor(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	tmp = np.empty((height, width, 3))
	tmp2 = np.empty((height, width, 3))
	
	mask = np.zeros((3, 3))
	mask[2, 1] = 1
	mask[1, 2] = -1
	
	# filtracja
	for i in range(height):
		for j in range(width):
			r, g, b = 0, 0, 0
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					r += self.im[iSafe, jSafe][0] * mask[iOff + 1, jOff + 1]
					g += self.im[iSafe, jSafe][1] * mask[iOff + 1, jOff + 1]
					b += self.im[iSafe, jSafe][2] * mask[iOff + 1, jOff + 1]
			resultImage[i, j] = (abs(r), abs(g), abs(b))
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "highpassRoberts")
	
\end{lstlisting}

\newpage


\section{Operator Prewitt'a}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Filtr Prewitt'a, podobnie jak filtr Roberts'a, służy do wykrywania krawiędzi i może w wyniku wygenerować wartość ujemną, aby temu zapobiec należy użyc wartości bezwzględnej. Maska Prewitt'a jest rozszerzeniem maski Roberts'a i nie jest tak wrażliwa na szum. Maska:

\begin{center}
	$\frac{1}{2}$
	\begin{tabular}{|c|c|c|}
		\hline
		-1 & 0 & 1\\
		\hline
		-1 & 0 & 1\\
		\hline
		-1 & 0 & 1\\
		\hline
	\end{tabular}
\end{center}

\begin{enumerate}
	\item Dla każdego piksla($P$):
	\item Dla każdego kanału($C$):
	\item Zsumuj wartości piksli $P_C$, otaczających piksel $P$ pomnożonych przez odpowiednią wagę maski.
	\item Zastosój wartość bezwzględną na otrzymanej sumie.
	\item Następnie podziel ją przez 2.
	\item Jeśli otrzymany wynik jest $> 255$.
	\item Przypisz mu wartość 255.
	\item Przypisz nową wartość barwy pikslowi $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_highpassPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Prewitt'a}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_highpassPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Prewitt'a}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_highpassPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Prewitt'a}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_highpassPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Prewitt'a}
\end{figure}
\newpage

%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Operator Prewitt'a (obraz szary)]
	
def prewittGray(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	mask = np.zeros((3, 3))
	mask[0, 0] = mask[1, 0] = mask[2, 0] = -1
	mask[0, 2] = mask[1, 2] = mask[2, 2] = 1
	
	# filtracja
	for i in range(height):
		for j in range(width):
			value = 0
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					value += self.im[iSafe, jSafe] * mask[iOff + 1, jOff + 1]
			resultImage[i, j] = abs(value / 2)
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "highpassPrewitt")
	
\end{lstlisting}

\newpage

%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Operator Prewitt'a (obraz barwny)]
	
def prewittColor(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	tmp = np.empty((height, width, 3))
	tmp2 = np.empty((height, width, 3))
	
	mask = np.zeros((3, 3))
	mask[0, 0] = mask[1, 0] = mask[2, 0] = -1
	mask[0, 2] = mask[1, 2] = mask[2, 2] = 1
	
	# filtracja
	for i in range(height):
		for j in range(width):
			r, g, b = 0, 0, 0
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					r += self.im[iSafe, jSafe][0] * mask[iOff + 1, jOff + 1]
					g += self.im[iSafe, jSafe][1] * mask[iOff + 1, jOff + 1]
					b += self.im[iSafe, jSafe][2] * mask[iOff + 1, jOff + 1]
			r, g, b = (abs(r)/2, abs(g)/2, abs(b)/2)
			if r > 255:
				r = 255
			if g > 255:
				g = 255
			if b > 255:
				b = 255
			resultImage[i, j] = (r, g, b)
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "highpassPrewitt")
	
\end{lstlisting}

\newpage

\section{Operator Sobel'a}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Filtr Prewitt'a, podobnie jak filtr Roberts'a, służy do wykrywania krawiędzi i może w wyniku wygenerować wartość ujemną, aby temu zapobiec należy użyc wartości bezwzględnej. Maska Prewitt'a jest rozszerzeniem maski Roberts'a i nie jest tak wrażliwa na szum. Maska:

\begin{center}
	$\frac{1}{4}$
	\begin{tabular}{|c|c|c|}
		\hline
		1 & 2 & 1\\
		\hline
		0 & 0 & 0\\
		\hline
		-1 & -2 & -1\\
		\hline
	\end{tabular}
\end{center}

\begin{enumerate}
	\item Dla każdego piksla($P$):
	\item Dla każdego kanału($C$):
	\item Zsumuj wartości piksli $P_C$, otaczających piksel $P$ pomnożonych przez odpowiednią wagę maski.
	\item Zastosój wartość bezwzględną na otrzymanej sumie.
	\item Następnie podziel ją przez 4.
	\item Jeśli otrzymana wartość jest $> 255$.
	\item Przypisz jej wartość 255.
	\item Przypisz nową wartość barwy pikslowi $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_highpassSobol_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Sobel'a}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_highpassSobol_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Sobel'a}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_highpassSobol_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Sobel'a}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_highpassSobol_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem Sobel'a}
\end{figure}
\newpage

%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Operator Sobel'a (obraz szary)]
	
def sobolGray(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	mask = np.zeros((3, 3))
	mask[0, 0] = mask[0, 2] = 1
	mask[2, 0] = mask[2, 2] = -1
	mask[0, 1] = 2
	mask[2, 1] = -2
	
	# filtracja
	for i in range(height):
		for j in range(width):
			value = 0
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					value += self.im[iSafe, jSafe] * mask[iOff + 1, jOff + 1]
			resultImage[i, j] = abs(value / 4)
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "highpassSobol")
	
\end{lstlisting}

\newpage

%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Operator Sobel'a (obraz barwny)]
	
def sobolColor(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	tmp = np.empty((height, width, 3))
	tmp2 = np.empty((height, width, 3))
	
	mask = np.zeros((3, 3))
	mask[0, 0] = mask[0, 2] = 1
	mask[2, 0] = mask[2, 2] = -1
	mask[0, 1] = 2
	mask[2, 1] = -2
	
	# filtracja
	for i in range(height):
		for j in range(width):
			r, g, b = 0, 0, 0
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					r += self.im[iSafe, jSafe][0] * mask[iOff + 1, jOff + 1]
					g += self.im[iSafe, jSafe][1] * mask[iOff + 1, jOff + 1]
					b += self.im[iSafe, jSafe][2] * mask[iOff + 1, jOff + 1]
			r = abs(r) / 2
			g = abs(g) / 2
			b = abs(b) / 2
			if r > 255:
				r = 255
			if g > 255:
				g = 255
			if b > 255:
				b = 255
			resultImage[i, j] = (r, g, b)
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "highpassSobol")
	
\end{lstlisting}

\newpage

\section{Filtr kompasowy}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Filtr kompasowy polega na splecieniu zbioru 8 masek wzornikowych, gdzie każda z nich jest czuła w innym kierunku. Dla każdego piksla wybierana jest maska o maksymalnej reakcji. Maski Sobel'a:

\begin{center}
	$\frac{1}{4}$
	\begin{tabular}{|c|c|c|}
		\hline
		-1 & 0 & 1\\
		\hline
		-2 & 0 & 2\\
		\hline
		-1 & 0 & 1\\
		\hline
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{4}$
	\begin{tabular}{|c|c|c|}
		\hline
		0 & 1 & 2\\
		\hline
		-1 & 0 & 1\\
		\hline
		-2 & -1 & 0\\
		\hline
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{4}$
	\begin{tabular}{|c|c|c|}
		\hline
		1 & 2 & 1\\
		\hline
		0 & 0 & 0\\
		\hline
		-1 & -2 & -1\\
		\hline
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{4}$
	\begin{tabular}{|c|c|c|}
		\hline
		2 & 1 & 0\\
		\hline
		1 & 0 & -1\\
		\hline
		0 & -1 & -2\\
		\hline
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{4}$
	\begin{tabular}{|c|c|c|}
		\hline
		1 & 0 & -1\\
		\hline
		2 & 0 & -2\\
		\hline
		1 & 0 & -1\\
		\hline
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{4}$
	\begin{tabular}{|c|c|c|}
		\hline
		0 & -1 & -2\\
		\hline
		1 & 0 & -1\\
		\hline
		2 & 1 & 0\\
		\hline
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{4}$
	\begin{tabular}{|c|c|c|}
		\hline
		-1 & -2 & -1\\
		\hline
		0 & 0 & 0\\
		\hline
		1 & 2 & 1\\
		\hline
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{4}$
	\begin{tabular}{|c|c|c|}
		\hline
		-2 & -1 & 0\\
		\hline
		-1 & 0 & 1\\
		\hline
		0 & 1 & 2\\
		\hline
	\end{tabular}
\end{center}

\begin{enumerate}
	\item Dla każdego piksla($P$):
	\item Dla każdego kanału($C$):
	\item Dla każdej z masek($M$):
	\item Zsumuj wartości piksli $P_C$, otaczających piksel $P$ pomnożonych przez odpowiednią wagę maski $M$.
	\item Zastosój wartość bezwzględną na otrzymanej sumie.
	\item Następnie podziel ją przez 4.
	\item Wybierz największą z wartości, która jest maksymalną reakcją gradientu.
	\item Przypisz nową wartość barwy pikslowi $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_compassSobol_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem kompasowym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_compassSobol_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem kompasowym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_compassSobol_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem kompasowym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_compassSobol_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem kompasowym}
\end{figure}


%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Filtr kompasowy (obraz szary)]
	
def compassGray(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	#maska
	mask = [0] * 8
	
	mask[0] = np.zeros((3, 3))
	mask[0][0, 2] = mask[0][2, 2] = 1
	mask[0][0, 0] = mask[0][2, 0] = -1
	mask[0][1, 2] = 2
	mask[0][1, 0] = -2
	
	mask[1] = np.zeros((3, 3))
	mask[1][0, 1] = mask[1][1, 2] = 1
	mask[1][1, 0] = mask[1][2, 1] = -1
	mask[1][0, 2] = 2
	mask[1][2, 0] = -2
	
	mask[2] = np.zeros((3, 3))
	mask[2][0, 0] = mask[2][0, 2] = 1
	mask[2][2, 0] = mask[2][2, 2] = -1
	mask[2][0, 1] = 2
	mask[2][2, 1] = -2
	
	mask[3] = np.zeros((3, 3))
	mask[3][0, 1] = mask[3][1, 0] = 1
	mask[3][1, 2] = mask[3][2, 1] = -1
	mask[3][0, 0] = 2
	mask[3][2, 2] = -2
	
	mask[4] = np.zeros((3, 3))
	mask[4][0, 0] = mask[4][2, 0] = 1
	mask[4][0, 2] = mask[4][2, 2] = -1
	mask[4][1, 0] = 2
	mask[4][1, 2] = -2
	
	mask[5] = np.zeros((3, 3))
	mask[5][1, 0] = mask[5][2, 1] = 1
	mask[5][0, 1] = mask[5][1, 2] = -1
	mask[5][2, 0] = 2
	mask[5][0, 2] = -2
	
	mask[6] = np.zeros((3, 3))
	mask[6][2, 0] = mask[6][2, 2] = 1
	mask[6][0, 0] = mask[6][0, 2] = -1
	mask[6][2, 1] = 2
	mask[6][0, 1] = -2
	
	mask[7] = np.zeros((3, 3))
	mask[7][1, 2] = mask[7][2, 1] = 1
	mask[7][0, 1] = mask[7][1, 0] = -1
	mask[7][2, 2] = 2
	mask[7][0, 0] = -2
	
	# filtracja
	for i in range(height):
		for j in range(width):
			value = [0] * 8
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
						jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
						for k in range(8):
						value[k] += self.im[iSafe, jSafe] * mask[k][iOff + 1, jOff + 1]
	
			resultImage[i, j] = max(map(abs, value)) / 4
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "compassSobol")
	
\end{lstlisting}

\newpage
%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Filtr kompasowy (obraz barwny)]
	
def compassColor(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	tmp = np.empty((height, width, 3))
	tmp2 = np.empty((height, width, 3))
	
	#maska
	mask = [0] * 8
	
	mask[0] = np.zeros((3, 3))
	mask[0][0, 2] = mask[0][2, 2] = 1
	mask[0][0, 0] = mask[0][2, 0] = -1
	mask[0][1, 2] = 2
	mask[0][1, 0] = -2
	
	mask[1] = np.zeros((3, 3))
	mask[1][0, 1] = mask[1][1, 2] = 1
	mask[1][1, 0] = mask[1][2, 1] = -1
	mask[1][0, 2] = 2
	mask[1][2, 0] = -2
	
	mask[2] = np.zeros((3, 3))
	mask[2][0, 0] = mask[2][0, 2] = 1
	mask[2][2, 0] = mask[2][2, 2] = -1
	mask[2][0, 1] = 2
	mask[2][2, 1] = -2
	
	mask[3] = np.zeros((3, 3))
	mask[3][0, 1] = mask[3][1, 0] = 1
	mask[3][1, 2] = mask[3][2, 1] = -1
	mask[3][0, 0] = 2
	mask[3][2, 2] = -2
	
	mask[4] = np.zeros((3, 3))
	mask[4][0, 0] = mask[4][2, 0] = 1
	mask[4][0, 2] = mask[4][2, 2] = -1
	mask[4][1, 0] = 2
	mask[4][1, 2] = -2
	
	mask[5] = np.zeros((3, 3))
	mask[5][1, 0] = mask[5][2, 1] = 1
	mask[5][0, 1] = mask[5][1, 2] = -1
	mask[5][2, 0] = 2
	mask[5][0, 2] = -2
	
	mask[6] = np.zeros((3, 3))
	mask[6][2, 0] = mask[6][2, 2] = 1
	mask[6][0, 0] = mask[6][0, 2] = -1
	mask[6][2, 1] = 2
	mask[6][0, 1] = -2
	
	mask[7] = np.zeros((3, 3))
	mask[7][1, 2] = mask[7][2, 1] = 1
	mask[7][0, 1] = mask[7][1, 0] = -1
	mask[7][2, 2] = 2
	mask[7][0, 0] = -2
	
	# filtracja
	for i in range(height):
		for j in range(width):
			r = [0] * 8
			g = [0] * 8
			b = [0] * 8
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					for k in range(8):
						r[k] += self.im[iSafe, jSafe][0] * mask[k][iOff + 1, jOff + 1]
						g[k] += self.im[iSafe, jSafe][1] * mask[k][iOff + 1, jOff + 1]
						b[k] += self.im[iSafe, jSafe][2] * mask[k][iOff + 1, jOff + 1]
	
			resultImage[i, j] = (max(map(abs, r)) / 4, max(map(abs, g)) / 4, max(map(abs, b)) / 4)
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "compassSobol")
	
\end{lstlisting}

\newpage

\section{Gradient wektora kierunkowego}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Filtr ten służy do wykrywania krawędzi w obrazie. Podobnie jak dla filtru kompasowego, filtr wektora kierunkowego polega na splecieniu 4 masek wzornikowych, gdzie każda z nich jest czuła w innym kierunku, a dla każdego piksla wybierana jest maska o maksymalnej reakcji. Maski Prewitt'a:

\begin{center}
	$\frac{1}{2}$
	\begin{tabular}{|c|c|c|}
		\hline
		-1 & 0 & 1\\
		\hline
		-1 & 0 & 1\\
		\hline
		-1 & 0 & 1\\
		\hline	
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{2}$
	\begin{tabular}{|c|c|c|}
		\hline
		1 & 1 & 1\\
		\hline
		0 & 0 & 0\\
		\hline
		-1 & -1 & -1\\
		\hline
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{2}$
	\begin{tabular}{|c|c|c|}
		\hline
		1 & 0 & -1\\
		\hline
		1 & 0 & -1\\
		\hline
		1 & 0 & -1\\
		\hline
	\end{tabular}
\end{center}

\begin{center}
	$\frac{1}{2}$
	\begin{tabular}{|c|c|c|}
		\hline
		-1 & -1 & -1\\
		\hline
		0 & 0 & 0\\
		\hline
		1 & 1 & 1\\
		\hline
	\end{tabular}
\end{center}


\begin{enumerate}
	\item Dla każdego piksla($P$):
	\item Dla każdego kanału($C$):
	\item Dla każdej z masek($M$):
	\item Zsumuj wartości piksli $P_C$, otaczających piksel $P$ pomnożonych przez odpowiednią wagę maski $M$.
	\item Zastosój wartość bezwzględną na otrzymanej sumie.
	\item Następnie podziel ją przez 4.
	\item Wybierz największą z wartości, która jest maksymalną reakcją gradientu.
	\item Przypisz nową wartość barwy pikslowi $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_vdgPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem wekora kierunkowego}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_vdgPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem wekora kierunkowego}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_vdgPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem wekora kierunkowego}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_vdgPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem wekora kierunkowego}
\end{figure}


%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Gradient wektora kierunkowego (obraz szary)]
	
def VDGGray(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	#maska
	mask = [0] * 4
	
	mask[0] = np.zeros((3, 3))
	mask[0][0, 2] = mask[0][2, 2] = 1
	mask[0][0, 0] = mask[0][2, 0] = -1
	mask[0][1, 2] = 1
	mask[0][1, 0] = -1
	
	mask[1] = np.zeros((3, 3))
	mask[1][0, 0] = mask[1][0, 2] = 1
	mask[1][2, 0] = mask[1][2, 2] = -1
	mask[1][0, 1] = 1
	mask[1][2, 1] = -1
	
	mask[2] = np.zeros((3, 3))
	mask[2][0, 0] = mask[2][2, 0] = 1
	mask[2][0, 2] = mask[2][2, 2] = -1
	mask[2][1, 0] = 1
	mask[2][1, 2] = -1
	
	mask[3] = np.zeros((3, 3))
	mask[3][2, 0] = mask[3][2, 2] = 1
	mask[3][0, 0] = mask[3][0, 2] = -1
	mask[3][2, 1] = 1
	mask[3][0, 1] = -1
	
	# filtracja
	for i in range(height):
		for j in range(width):
			value = [0] * 4
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
				iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
				jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
				for k in range(4):
					value[k] += self.im[iSafe, jSafe] * mask[k][iOff + 1, jOff + 1]
	
			resultImage[i, j] = max(map(abs, value)) / 2
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "vdgSobol")
	
\end{lstlisting}

\newpage
%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Gradient wektora kierunkowego (obraz barwny)]
	
def VDGColor(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	tmp = np.empty((height, width, 3))
	tmp2 = np.empty((height, width, 3))

	#maska
	mask = [0] * 4
	
	mask[0] = np.zeros((3, 3))
	mask[0][0, 2] = mask[0][2, 2] = 1
	mask[0][0, 0] = mask[0][2, 0] = -1
	mask[0][1, 2] = 1
	mask[0][1, 0] = -1
	
	mask[1] = np.zeros((3, 3))
	mask[1][0, 0] = mask[1][0, 2] = 1
	mask[1][2, 0] = mask[1][2, 2] = -1
	mask[1][0, 1] = 1
	mask[1][2, 1] = -1
	
	mask[2] = np.zeros((3, 3))
	mask[2][0, 0] = mask[2][2, 0] = 1
	mask[2][0, 2] = mask[2][2, 2] = -1
	mask[2][1, 0] = 1
	mask[2][1, 2] = -1
	
	mask[3] = np.zeros((3, 3))
	mask[3][2, 0] = mask[3][2, 2] = 1
	mask[3][0, 0] = mask[3][0, 2] = -1
	mask[3][2, 1] = 1
	mask[3][0, 1] = -1
	
	# filtracja
	for i in range(height):
		for j in range(width):
			r = [0] * 4
			g = [0] * 4
			b = [0] * 4
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					for k in range(4):
						r[k] += self.im[iSafe, jSafe][0] * mask[k][iOff + 1, jOff + 1]
						g[k] += self.im[iSafe, jSafe][1] * mask[k][iOff + 1, jOff + 1]
						b[k] += self.im[iSafe, jSafe][2] * mask[k][iOff + 1, jOff + 1]
	
			resultImage[i, j] = (max(map(abs, r)) / 4, max(map(abs, g)) / 4, max(map(abs, b)) / 4)
	
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "vdgSobol")
	
\end{lstlisting}

\newpage

\section{Filtr medianowy}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Jeden z filtrów statystycznych, którego efekt opiera się na wyborze odpowiedniego piksla pod maską. Filtr medianowy (środkowy) opiera się na medianie, czyli wartości środkowej spośród uporządkowanych wartości piksli z otoczenia badanego piksla. Filtr ten stosuje się do redukcji szumu w obrazie.

\begin{enumerate}
	\item Dla każdego piksla ($P$):
	\item Dla każdej z barw ($C$):
	\item Umieść wartości barwy $C$ piksli z otoczenia piksla $P$ w tablicy jednowymiarowej.
	\item Posortuj rosnąco wartości barwy $C$, a następnie wybierz medianę.
	\item Przypisz znalezioną mediane jako nową wartość barwy piksla $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_noise}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_noise_median_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem medianowym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray_noise}
		\includegraphics[width=0.35\textwidth]{pirate_gray_noise_median_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem medianowym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color_noise}
		\includegraphics[width=0.35\textwidth]{lena_color_noise_median_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem medianowym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color_noise}
		\includegraphics[width=0.35\textwidth]{peppers_color_noise_median_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem medianowym}
\end{figure}

\newpage

%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Filtr medianowy (obraz szary)]
	
def medianGray(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	for i in range(height):
		for j in range(width):
			median = [0] * 9
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					median[3*(1 + iOff) + jOff + 1] = self.im[iSafe, jSafe]
			median.sort()
			u = int(round(len(median)/2))
			resultImage[i, j] = median[u] if ((u*2) % 2 == 0) else ((median[u - 1] + median[u])/2)
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "median")
	
\end{lstlisting}

\newpage

%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Filtr medianowy (obraz brawny)]
	
def medianColor(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	
	for i in range(height):
		for j in range(width):
			r = [0] * 9
			g = [0] * 9
			b = [0] * 9
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					r[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe][0]
					g[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe][1]
					b[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe][2]
			r.sort()
			g.sort()
			b.sort()
			ur = int(round(len(r) / 2))
			ug = int(round(len(g) / 2))
			ub = int(round(len(b) / 2))
			resultImage[i, j] = (r[ur] if ((ur*2) % 2 == 0) else ((r[ur - 1] + r[ur])/2), g[ug] if ((ug*2) % 2 == 0) else ((g[ug - 1] + g[ug])/2), b[ub] if ((ub*2) % 2 == 0) else ((b[ub - 1] + b[ub])/2))
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "median")
	
\end{lstlisting}

\newpage
\section{Filtr maksymalny}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent  Jeden z filtrów statystycznych, którego efekt opiera się na wyborze odpowiedniego piksla pod maską. Zwany jest także filtrem dekompresujacym albo ekspansywnym. Jego działanie polega na wybraniu z pod maski punktu o wartości największej. Jego działanie powoduje zwiększenie jasności obrazu, daje to efekt powiększania się obiektów.

\begin{enumerate}
	\item Dla każdego piksla ($P$):
	\item Dla każdej z barw ($C$):
	\item Umieść wartości barwy $C$ piksli z otoczenia piksla $P$ w tablicy jednowymiarowej.
	\item Posortuj rosnąco wartości barwy $C$, a następnie wybierz ostatni(największy) element.
	\item Przypisz znalezioną wartość jako nową wartość barwy piksla $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_max_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem maksymalnym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_max_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem maksymalnym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_max_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem maksymalnym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_max_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem maksymalnym}
\end{figure}

\newpage

%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Filtr maksymalny (obraz szary)]
	
def maxGray(self, show=False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	for i in range(height):
		for j in range(width):
			median = [0] * 9
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					median[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe]
			median.sort()
			resultImage[i, j] = median[len(median) - 1]
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "max")
	
\end{lstlisting}

\newpage
%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Filtr maksymalny (obraz barwny)]
	
def maxColor(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	
	for i in range(height):
		for j in range(width):
			r = [0] * 9
			g = [0] * 9
			b = [0] * 9
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					r[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe][0]
					g[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe][1]
					b[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe][2]
			r.sort()
			g.sort()
			b.sort()
			resultImage[i, j] = (r[len(r) - 1], g[len(g) - 1], b[len(b) - 1])
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "max")
	
\end{lstlisting}



\newpage
\section{Filtr minimalny}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent  Jeden z filtrów statystycznych, którego efekt opiera się na wyborze odpowiedniego piksla pod maską. Zwany jest także filtrem kompresujacym albo erozyjnym. Jego działanie polega na wybraniu z pod maski punktu o wartości najmniejszej. Jego działanie powoduje zmniejszenie jasności obrazu,  daje to efekt erozji obiektów. 

\begin{enumerate}
	\item Dla każdego piksla ($P$):
	\item Dla każdej z barw ($C$):
	\item Umieść wartości barwy $C$ piksli z otoczenia piksla $P$ w tablicy jednowymiarowej.
	\item Posortuj rosnąco wartości barwy $C$, a następnie wybierz pierwszy(najmniejszy) element.
	\item Przypisz znalezioną wartość jako nową wartość barwy piksla $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_min_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem minimalnym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_min_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem minimalnym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_min_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem minimalnym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_min_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem minimalnym}
\end{figure}

%\subsection*{Kod źródłowy dla obrazów szarych}
\newpage

\begin{lstlisting}[caption=Filtr minimalny (obraz szary)]
	
def minGray(self, show=False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	for i in range(height):
		for j in range(width):
			median = [0] * 9
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					median[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe]
			median.sort()
			resultImage[i, j] = median[0]
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "min")
	
\end{lstlisting}


\newpage
%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Filtr minimalny (obraz barwny)]
	
def minColor(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	
	for i in range(height):
		for j in range(width):
			r = [0] * 9
			g = [0] * 9
			b = [0] * 9
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					r[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe][0]
					g[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe][1]
					b[3 * (1 + iOff) + jOff + 1] = self.im[iSafe, jSafe][2]
			r.sort()
			g.sort()
			b.sort()
			resultImage[i, j] = (r[0], g[0], b[0])
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "min")
	
\end{lstlisting}
\newpage



\section{Filtr płaskorzeźbowy}
\subsection*{Opis algorytmu}
\hfill
\\\\
\indent Filtr płaskorzeźbowy swoją nazwę zdobył od efektu jaki generuje jego maska, obrazy przepuszczone przez ten filtr, w efekcie przypominają płaskorzeźbę. Sposób definiowania kierunków jest podobny jak w przypadku kierunkowych filtrów gradientowych. Różnicą jest jedynie wartość środkowa mająca wartość 1. W tym programie została użyta maska Prewitt'a. Maska:

\begin{center}
	$\frac{1}{2}$ 
	\begin{tabular}{|c|c|c|}
		\hline
		-1 & 0 & 1\\
		\hline
		-1 & 1 & 1\\
		\hline
		-1 & 0 & 1\\
		\hline
	\end{tabular}
\end{center}

\begin{enumerate}
	\item Dla każdego piksla($P$):
	\item Dla każdego kanału($C$):
	\item Zsumuj wartości piksli $P_C$, otaczających piksel $P$ pomnożonych przez odpowiednią wagę maski.
	\item Zastosój wartość bezwzględną na otrzymanej sumie.
	\item Następnie podziel ją przez 2.
	\item Jeśli otrzymana wartość jest $> 255$.
	\item Przypisz jej wartość 255.
	\item Przypisz nową wartość barwy pikslowi $P$.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{gentelman_gray}
		\includegraphics[width=0.35\textwidth]{gentelman_gray_reliefPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem płaskorzeźbowym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{pirate_gray}
		\includegraphics[width=0.35\textwidth]{pirate_gray_reliefPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem płaskorzeźbowym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{lena_color}
		\includegraphics[width=0.35\textwidth]{lena_color_reliefPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem płaskorzeźbowym}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{peppers_color}
		\includegraphics[width=0.35\textwidth]{peppers_color_reliefPrewitt_result}
	\end{center}
	\caption{Obraz wejściowy, obraz po filtracji filtrem płaskorzeźbowym}
\end{figure}
\newpage

%\subsection*{Kod źródłowy dla obrazów szarych}

\begin{lstlisting}[caption=Filtr płaskorzeźbowy (obraz szary)]
	
def reliefGray(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width), dtype=np.uint8)
	
	mask = np.zeros((3, 3))
	mask[0, 0] = mask[1, 0] = mask[2, 0] = -1
	mask[0, 2] = mask[1, 2] = mask[2, 2] = 1
	mask[1, 1] = 1
	
	# filtracja
	for i in range(height):
		for j in range(width):
		value = 0
		for iOff in range(-1, 2):
			for jOff in range(-1, 2):
				iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
				jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
				value += self.im[iSafe, jSafe] * mask[iOff + 1, jOff + 1]
			value = abs(value) / 2
			if value > 255:
				value = 255
			resultImage[i, j] = value
	
	
	if show:
		self.show(Image.fromarray(resultImage, "L"))
	self.save(resultImage, self.imName, "reliefPrewitt")
	
\end{lstlisting}

\newpage

%\subsection*{Kod źródłowy dla obrazów barwnych}

\begin{lstlisting}[caption=Filtr płaskorzeźbowy (obraz barwny)]
	
def reliefColor(self, show = False):
	width = self.im.shape[1]  # szereoksc
	height = self.im.shape[0]  # wysokosc
	
	# alokacja pamieci na obraz wynikowy
	resultImage = np.empty((height, width, 3), dtype=np.uint8)
	tmp = np.empty((height, width, 3))
	tmp2 = np.empty((height, width, 3))
	
	mask = np.zeros((3, 3))
	mask[0, 0] = mask[1, 0] = mask[2, 0] = -1
	mask[0, 2] = mask[1, 2] = mask[2, 2] = 1
	mask[1, 1] = 1
	
	# filtracja
	for i in range(height):
		for j in range(width):
			r, g, b = 0, 0, 0
			for iOff in range(-1, 2):
				for jOff in range(-1, 2):
					iSafe = i if ((i + iOff) > (height - 1)) else (i + iOff)
					jSafe = j if ((j + jOff) > (width - 1)) else (j + jOff)
					r += self.im[iSafe, jSafe][0] * mask[iOff + 1, jOff + 1]
					g += self.im[iSafe, jSafe][1] * mask[iOff + 1, jOff + 1]
					b += self.im[iSafe, jSafe][2] * mask[iOff + 1, jOff + 1]
			r = abs(r) / 2
			g = abs(g) / 2
			b = abs(b) / 2
			if r > 255:
				r = 255
			if g > 255:
				g = 255
			if b > 255:
				b = 255
			resultImage[i, j] = (r, g, b)
	
	if show:
		self.show(Image.fromarray(resultImage, "RGB"))
	self.save(resultImage, self.imName, "reliefPrewitt")
	
\end{lstlisting}

L ~\cite{BookMok} %przynajmniej jedna cytacja dla kompilatora LATEX

\newpage



\bibliographystyle{plain}
\bibliography{literatura}

\end{document} 