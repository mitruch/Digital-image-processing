\documentclass[final,a4paper,openany,12pt]{mwbk}
%\documentclass[final,a4paper,openright,12pt]{mwbk} % każdy rozdział zaczyna się na stronie nieparzystej
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{url}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumerate}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{titlesec}
\usepackage{amsmath}
\usepackage{listings}
\lstset{
language=Python,
breaklines=true,
tabsize=2,
breaklines  = true,
breakatwhitespace   = false,
prebreak= \space,
postbreak   = \space  
}   



\titleformat{\section}[runin]
{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}[runin]
{\normalfont\large\bfseries}{\thesubsection}{1em}{}




\usepackage{makeidx}  % allows index generation
\usepackage{graphicx} % standard LaTeX graphics tool
                      % for including eps-figure files
\graphicspath{{img/}{img/Zegarek}}
\usepackage{float}


%\prefixing %polskie znaki: /a /c /e /z /x /o /s /l /A /C itd. %ZAKOMENTOWANE BO SIE NIE DA UZYWAC "/"

\renewcommand*\listalgorithmname{Spis algorytmów\protect} % łatka na niedoróbkę w spisie algorytmów - nie usuwać!

% zestaw przydatny, kiedy trzeba regulować szerokość kolumn w tablicy:
%%\usepackage{longtable}
%\usepackage{array}
%\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
%\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
%\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\newtheorem{twr}{Twierdzenie}[section]

% ustawienia do wydruku dwustronnego z uwzględnieniem dodatkowego miejsca na zszycie
\setlength{\oddsidemargin}{0.46cm}   %margines nieparzysty
\setlength{\evensidemargin}{-0.54cm} %margines parzysty
\setlength{\textwidth}{16cm}         %szerokość tekstu na stronie
\linespread{1.1}    % lekkie zwiększenie odstępu między liniami, żeby tekst nie był taki ścisły, ponieważ
                    % Odstęp pojedynczej interlinii nie jest komfortowy, kiedy trzeba czytać strony A4
% koniec ustawień

%\makeindex            % used for the subject index
                      % please use the style sprmidx.sty with
                      % your makeindex program
\begin{document}

\begin{titlepage}
\vspace{-0.5cm}

{\centering
{\footnotesize
\begin{tabular}{c}
UNIWERSYTET KARDYNAŁA STEFANA WYSZYŃSKIEGO\\
W WARSZAWIE\\
\end{tabular}
}
\vspace{2.5cm}

{\footnotesize
\begin{tabular}{c}
WYDZIAŁ MATEMATYCZNO-PRZYRODNICZY\\
SZKOŁA NAUK ŚCISŁYCH\\
\end{tabular}
}
\vspace{2.5cm}

\renewcommand{\arraystretch}{1.5} % zwiększamy odległość między wierszami

{\normalsize
\begin{tabular}{c}
Katarzyna Mitrus\\
Michał Słotwiński\\
\end{tabular}
}

\vspace{1.5cm}

{\large
\begin{tabular}{c}

Wprowadzenie do Przetwarzania Obrazów\\
Sprawozdanie z laboratorium\\

\end{tabular}
}

}

\renewcommand{\arraystretch}{1} % przywracamy domyślną odległość miedzy wierszami

\vspace{5cm}

\hspace{6cm}
\begin{tabular}{l}
Prowadzący:\\
prof. Wojciech Mokrzycki\\

\end{tabular}

\vspace{4cm}

{\centering

{\small
\begin{tabular}{c}
{Warszawa, 2018}\\
\end{tabular}
}

}
\end{titlepage}

\tableofcontents
\listoffigures
%\listoftables
%\listofalgorithms

\sloppy


\chapter {Wstęp}

Laboratoria...~\cite{BookMok} %przynajmniej jedna cytacja dla kompilatora LATEX


\section {Specyfikacja wykorzystanego fortmatu obrazu}

\section {Intstrukcja obsługi programu}



\chapter{Operacje ujednolicania obrazów}
1. ujednolicenie obrazów szarych geometryczne (liczba wierszy i kolumn piksli)
2. ujednolicenie obrazów szarych rozdzielczościowe (w rastrze)
3. ujednolicenie obrazów RGB geometryczne (liczba wierszy i kolumn piksli)
4. ujednolicenie obrazów RGB rozdzielczościowe (w rastrze)

\chapter{Operacje sumowania arytmetycznego obrazów szarych}

Arytmetyczne operacje między pikslami $p$ i $q$ dwóch obrazów są używane w wielu działach przetwarzania obrazów. Przeprowadzane się je wykonując działania na pojedynczych pikslach i są uwarunkowane wymaganiami zależnymi od typu operacji. 
Po operacjach arytmetycznych zwykle niezbędna jest normalizacja. W przedstawionych zadaniach do normalizacji wykorzystano wzór:
	
	\begin{center}
		$ f_{norm} = Z_{rep}[(f - f_{min}) / (f_{max} - f_{min})] $
	\end{center}

\section {Sumowanie (określonej) stałej z obrazem}
\hfill\\
\indent
Algorytm sumowania obrazu szarego z określoną stałą polega na dodaniu do każdej wartości pojedynczego piksla stałej liczby.
Po operacji sumowania następuje normalizacja obrazu.

	\begin{enumerate}	
		\item Policz sumy wartości kazdego piksla ze stałą ($const$).
		\item Jeżeli jedna z tych sum jest większa niż 255 to:
		\item Wybierz największą sumę  $Q_{max}$ i policz $D_{max}$ ze wzoru: $D_{max}[i,j] = (Q_{max}[i,j] - 255)$ 
		\item Oblicz $X = D_{max} / 255$
		\item Policz sumy ze wzoru
		\begin{center}$Q[i,j] = P[i,j] - (P[i,j]* X) + const - (const * X) $ \\

		\end{center}
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Sum_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Sum_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po sumowaniu ze stałą = 50, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Sum_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Sum_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po sumowaniu ze stałą = 100, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Sumowanie obrazu szarego ze stałą]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
Q_max = 0
D_max = 0
X = 0
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  
        # Obliczanie sumy
        L = int(image_matrix[x][y]) + int(const)

        # Poszukiwanie maksimum
        if Q_max < L:
            Q_max = L

# Sprawdzenie czy przekracza zakres
if Q_max > 255:
    D_max = Q_max - 255
    X = (D_max/255)

# Obliczenie sumy z uwzglednieniem zakresu
for y in range(height):
    for x in range(width): 
        L = (image_matrix[x][y] - (image_matrix[x][y] * X)) + (const - (const * X))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}



\section {Sumowanie dwóch obrazów}
\hfill\\
\indent

Algebraiczne sumowanie obrazów f i f' jest określone jedynie dla obrazów o tych samych wymiarach M x N i strukturze ich macierzy.
Dodawanie obrazów jest użyteczne w uśrednianiu obrazów, wykonywanym w celu zredukowania na nich szumu.
Algorytm sumowania obrazu z obrazem polega na dodaniu do wartości piksla z pierwszego obrazu, wartości odpowiadającego piksla z drugiego obrazu.
Po operacji sumowania następuje normalizacja obrazu.

	\begin{enumerate}	
		\item Policz sumy wartości kazdego piksla obrazu pierwszego P1[i,j] z pikslem obrazu drugiego P2[i,j].
		\item Jeżeli jedna z tych sum jest większa niż 255 to:
		\item Wybierz największą sumę  $Q_{max}$ i policz $D_{max}$ ze wzoru: $D_{max}[i,j] = (Q_{max}[i,j] - 255)$ 
		\item Oblicz $X = D_{max} / 255$
		\item Policz sumy ze wzoru
		\begin{center}$Q[i,j] = P1[i,j] - (P1[i,j]* X) + P2[i,j] - (P2[i,j] * X) $ \\

		\end{center}
	\end{enumerate}


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img1_Sum_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img2_Sum_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Sum_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to szare obrazy wejściowe, następnie obraz powstały w wyniku sumowania obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img1_Sum_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img2_Sum_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Sum_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to szare obrazy wejściowe, następnie obraz powstały w wyniku sumowania obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}


\begin{lstlisting}[caption=Sumowanie obrazów szarych]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
Q_max = 0
D_max = 0
X = 0
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sumy
        L = int(image1_matrix[x][y]) + int(image2_matrix[x][y])

        # Poszukiwanie maksimum
        if Q_max < L:
            Q_max = L

# Sprawdzenie czy przekracza zakres
if Q_max > 255:
    D_max = Q_max - 255
    X = (D_max/255)

# Obliczenie sumy z uwzglednieniem zakresu
for y in range(height):
    for x in range(width): 
        L = (image1_matrix[x][y] - (image1_matrix[x][y] * X)) + (image2_matrix[x][y] - (image2_matrix[x][y] * X))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)
        
        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}

\section {Mnożenie obrazu przez zadaną liczbę}
\hfill\\
\indent

Mnożenie obrazu f przez skalar wykonuje się mnożąc każdy element obrazu $f_{i,j}$ (wartość funkcji obrazowej piksla) przez ten skalar.

\begin{enumerate}
		\item Dla wszystkich pikseli w obrazie wykonaj:
		\item Jeżli składowa piksela $P_{1}[i,j]$ ma wartość 255 to składowa wynikowa otrzymuje wartość odpowiadającą wartości stalej.
		\item W przeciwnym przypadku, jeżeli składowa barwy piksla $P_{1}[i,j]$ ma wartość 0 to składowa wynikowa otrzymuje wartość 0.
		\item W przeciwnym wypadku mnóż odpowiednie składowe, a wynik dziel przez 255 zaokrąglajac do najbliższej liczby całkowitej.
	\end{enumerate}


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Multipl_Result} 
		\includegraphics[width=0.3\textwidth]{1/1Gray_Const_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po przemnożeniu przez liczbę=50, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Const_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po przemnożeniu przez liczbę=100, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Mnożenie obrazu szarego przez zadaną liczbę]

iimage1_matrix = self.im1
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

# Mnozenie 
for y in range(height):
    for x in range(width):  

        L = int(image1_matrix[x][y]) 
        if L == 255:
            L = const
        elif L == 0:
            L = 0
        else:
            L = (int(image1_matrix[x][y]) * const)/255 

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}


\section {Mnożenie obrazu przez inny obraz}
\hfill\\
\indent

Mnożenie obrazu f przez inny obraz wykonuje się mnożąc każdy element obrazu $P1_{i,j}$ (wartość funkcji obrazowej piksla) przez odpowiadającego piksla drugiego obrazu $P2_{i,j}$

	\begin{enumerate}
		\item Weź dwa identycznych rozmiarów obrazy $P_{1}$ i $P_{2}$.
		\item Dla wszystkich pikseli w obrazie wykonaj:
		\item Jeżli składowa piksela $P_{1}[i,j]$ ma wartość 255 to składowa wynikowa otrzymuje wartość odpowiadającą wartości składowej $P_{2}[i,j]$.
		\item W przeciwnym przypadku, jeżli składowa piksela $P_{1}[i,j]$ ma wartość 0 to składowa wynikowa otrzymuje wartość 0.
		\item W przeciwnym wypadku mnóż odpowiednie składowe, a wynik dziel przez 255 zaokrąglając do najbliższej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img1_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img2_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to szare obrazy wejściowe, następnie obraz powstały w wyniku przemnożenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img1_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img2_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to szare obrazy wejściowe, następnie obraz powstały w wyniku przemnożenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Mnożenie obrazu szarego przez inny obraz ]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        L = int(image1_matrix[x][y]) 
        if L == 255:
            L = image2_matrix[x][y]
        elif L == 0:
            L = 0
        else:
            L = (int(image1_matrix[x][y]) * int(image2_matrix[x][y]))/255 

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)
                        
        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}

%\section {Mnożenie obrazu przez zadaną liczbę oraz przez inny obraz}
\section {Mieszanie obrazów z określonym współczynnikiem}
\hfill\\
\indent
\vspace{5mm}

Mieszanie dwóch obrazów polega na sumowaniu ich z wagami $\alpha$ i $(1 - \alpha)$, odpowiednio, wg wzoru:
	
	\begin{center}
		$f_{m} = f\alpha + f^I(1 - \alpha)$,
	\end{center}
	gdzie $\alpha \in [0,1]$. Płynna zmiana parametru $\alpha$ w przedziale $[0,1]$ powoduje efekt przechodzenia obrazu $f^I$ w obraz $f$. 
	
	\begin{enumerate}	
		\item Weź dwa identycznych rozmiarów obrazy $P_{1}$ i $P_{2}$.
		\item Określ współczynnik mieszania $\alpha$ wyrażony jako liczba rzeczywista z zakresu $< 0,1 >$; 0 reprezentuje pewną przezroczystość, 1 - nieprzezroczystości. 
		\item Dla wszystkich pikseli w obrazach wejściowych wykonuj $Q(i,j) = \alpha * P_{1}(i,j) + (1 - \alpha) * P_{2}(i,j)$
	\end{enumerate}


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img1_Mix_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img2_Mix_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Mix_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Mix_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku mieszania obrazów ze współczynnikiem $\alpha$=0.5, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img1_Mix_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img2_Mix_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Mix_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Mix_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku mieszania obrazów ze współczynnikiem $\alpha$=0.8, poniżej obraz wynikowy po normalizacji }
\end{figure}


\begin{lstlisting}[caption=Mieszanie obrazów szarych z określonym współczynnikiem]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        L = float(image1_matrix[x][y]) * alfa + (1-alfa) * float(image2_matrix[x][y])

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))
        
\end{lstlisting}



\section {Potęgowanie obrazu (z zadaną potęgą)}
\hfill\\
\indent

		\begin{center} Potęgowanie obrazu jest szczególnym przypadkiem operacji mnożenia obrazów. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru ~\cite{WykRat}:

		$f_{m} = 255(\frac{f(x,y)}{f_{max}}) ^{\alpha}, \alpha > 0 $
	\end{center}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Pow_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Pow_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Pow_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po podniesieniu do potęgi $\alpha$=2, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Pow_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Pow_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Pow_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po podniesieniu do potęgi $\alpha$=3, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Potęgowanie obrazu szarego (z zadaną potęgą)]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

for y in range(height):
    for x in range(width):  
        
        L = int(image_matrix[x][y])

        # Poszukiwanie maksimum
        if f_img_max < L:
            f_img_max = L

for y in range(height):
    for x in range(width):  
        
        L = int(image_matrix[x][y])
        if L == 255:
            L = 255
        elif L == 0:
            L = 0
        else:
            L = math.pow(int(image_matrix[x][y]) / f_img_max, alfa) * 255

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))



\end{lstlisting}

\section {Dzielenie obrazu przez (zadaną) liczbę }
\hfill\\
\indent
Dzielenie obrazów stosuje się w celu korekcji cieniowania między poziomami szarości.

\begin{enumerate}	
		
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Policz sumy piksli ze stałą.
		\item Wybierz największę sumę $Q_{max}$ i policz równania:\\
		$Q_[i,j] = ({S} * 255)/Q_{max}$,\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Div_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Div_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po podzieleniu przez liczbę=15, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Div_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Div_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po podzieleniu przez liczbę=3, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Dzielenie obrazu szarego przez (zadaną) liczbę ]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  

        L = int(image_matrix[x][y]) + int(const)

        # Poszukiwanie maksimum
        if Q_max < L:
            Q_max = L

for y in range(height):
    for x in range(width):  

        L = int(image_matrix[x][y]) + int(const)
        Q_L = (L * 255) / Q_max

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(Q_L)

        # Poszukiwanie minimum i maksimum
        if f_min > Q_L:
            f_min = Q_L
        if f_max < Q_L:
            f_max = Q_L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))
        
        
\end{lstlisting}

\section {Dzielenie obrazu przez przez inny obraz}
\vspace{5mm}
	\begin{enumerate}	
		\item Weź dwa identycznych rozmiarów obrazy $P1$ i $P2$
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Policz sumy piksli ze stałą.
		\item Wybierz największę sumę $Q_{max}$ i policz równania:\\
		$Q_[i,j] = ({S} * 255)/Q_{max}$,\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img1_Div_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img2_Div_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Div_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Img_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku podzielenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img1_Div_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img2_Div_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Div_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Img_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku podzielenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}


\begin{lstlisting}[caption=Dzielenie obrazu szarego przez przez inny obraz]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  
        # Obliczanie sumy
        L = int(image1_matrix[x][y]) + int(image2_matrix[x][y])
        
        # Poszukiwanie maksimum
        if Q_max < L:
            Q_max = L

for y in range(height):
    for x in range(width):  

        # Obliczanie sumy
        L = int(image1_matrix[x][y]) + int(image2_matrix[x][y])
        Q_L = (L * 255) / Q_max

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(Q_L)

        # Poszukiwanie minimum i maksimum
        if f_min > Q_L:
            f_min = Q_L
        if f_max < Q_L:
            f_max = Q_L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}


\section {Pierwiastkowanie obrazu}
\hfill\\
\indent
		\begin{center} Pierwiastkowanie obrazu jest szczególnym przypadkiem operacji potęgowania obrazów, gdzie wykładnikiem jest ułamek. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru ~\cite{WykRat}:

		$f_{m} = 255(\frac{f(x,y)}{f_{max}}) ^{\alpha}, \alpha > 0 $
	\end{center}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Sqrt_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Sqrt_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Sqrt_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po spierwiastkowaniu pierwiastkiem kwadratowym ($\alpha$=1/2), obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Sqrt_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Sqrt_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Sqrt_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po spierwiastkowaniu pierwiastkiem stopnia trzeciego ($\alpha$=1/3), obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Pierwiastkowanie obrazu szarego]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

alfa = 1/deg # Zamiana stopnia pierwiastka na ulamek

for y in range(height):
    for x in range(width):  
        
        L = int(image_matrix[x][y])

        # Poszukiwanie maksimum
        if f_img_max < L:
            f_img_max = L

for y in range(height):
    for x in range(width):  
        
        L = int(image_matrix[x][y])
        if L == 255:
            L = 255
        elif L == 0:
            L = 0
        else:
            L = math.pow(int(image_matrix[x][y]) / f_img_max, alfa) * 255

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))

\end{lstlisting}

\section {Logarytmowanie obrazu}
\hfill\\
\indent
Logarytmowanie obrazu powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu.
Wykorzystano wzór z normalizacją ~/cite{WykRat}:
	
	\begin{center}
		$f_{m} = 255(frac{log(1 + f(x,y))}{log(1 + f_{max})})$
	\end{center}

	
Przesunięcie funkcji obrazowej $f$ do góry o 1 przed jej logarytmowaniem wynika z nieokreśloności logarytmu w zerze. Logarytmowanie obrazu powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu. .	


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Log_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Log_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Log_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Log_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Log_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Log_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Logarytmowanie obrazu szarego]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

for y in range(height):
    for x in range(width):  

        L = int(image_matrix[x][y]) 

        # Poszukiwanie maksimum
        if f_img_max < L:
            f_img_max = L

for y in range(height):
    for x in range(width):  

        L = int(image_matrix[x][y]) 

        if L == 0:
            L = 0
        else:
            L = (math.log(1 + L) / math.log(1 + f_img_max)) * 255

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y] = math.ceil(L)

        # Poszukiwanie minimum i maksimum
        if f_min > L:
            f_min = L
        if f_max < L:
            f_max = L

# Normalizacja
norm_matrix = np.zeros((width, height), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y] = 255 * ((result_matrix[x][y] - f_min) / (f_max - f_min))


\end{lstlisting}


\chapter{Operacje sumowania arytmetycznego obrazów barwowych}
\hfill\\
\indent
Arytmetyczne operacje na obrazach barwowych przeprowadza się wykonując działania na pojedynczych pikslach i są uwarunkowane wymaganiami zależnymi od typu operacji. 
W przedstawionych zadaniach poruszamy się w przestrzeni barw RGB, a do normalizacji wykorzystano wzór:

	\begin{center}
		$ f_{norm} = Z_{rep}[(f - f_{min}) / (f_{max} - f_{min})] $
	\end{center}


\section{Sumowanie (określonej) stałej z obrazem}
\hfill\\
\indent
Algorytm sumowania obrazu barwowego z określoną stałą polega na dodaniu do każdej składowej barwowej pojedynczego piksla stałej liczby.
Po operacji sumowania obraz poddawany jest normalizacji.

	\begin{enumerate}	
		\item Policz sumy wartości kazdego piksla ze stałą ($const$).
		\item Jeżeli jedna z tych sum jest większa niż 255 to:
		\item Wybierz największą sumę  $Q_{max}$ i policz $D_{max}$ ze wzoru: $D_{max}[i,j] = (Q_{max}[i,j] - 255)$ 
		\item Oblicz $X = D_{max} / 255$
		\item Policz sumy ze wzoru
		\begin{center}$Q_{R}[i,j] = P_{R}[i,j] - (P_{R} * X)+ const - (const * X) -1$ \\
			$Q_{G}[i,j] = P_{G}[i,j] - (P_{G} * X)+ const - (const * X) -1$ \\
			$Q_{B}[i,j] = P_{B}[i,j] - (P_{B} * X)+ const - (const * X) -1$
		\end{center}
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Sum_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Sum_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po sumowaniu ze stałą = 50, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Sum_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Sum_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Sum_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po sumowaniu ze stałą = 100, obraz po normalizacji }
\end{figure}

\begin{lstlisting}[caption=Sumowanie obrazu barwowego ze stałą]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
Q_max = 0
D_max = 0
X = 0
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R = int(image_matrix[x][y][0]) + int(const)
        G = int(image_matrix[x][y][1]) + int(const)
        B = int(image_matrix[x][y][2]) + int(const)

        # Poszukiwanie maksimum               
        if Q_max < max([R, G, B]):
            Q_max = max([R, G, B])

# Sprawdzenie czy maksimum przekracza zakres
if Q_max > 255:
    D_max = Q_max - 255
    X = (D_max/255) # Obliczenie proporcji

# Obliczenie sum z uwzglednieniem zakresu
for y in range(height):
    for x in range(width): 
        R = (image_matrix[x][y][0] - (image_matrix[x][y][0] * X)) + (const - (const * X))
        G = (image_matrix[x][y][1] - (image_matrix[x][y][1] * X)) + (const - (const * X))
        B = (image_matrix[x][y][2] - (image_matrix[x][y][2] * X)) + (const - (const * X))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}

\section {Sumowanie dwóch obrazów}
\hfill\\
\indent
Algebraiczne sumowanie obrazów f i f' jest określone jedynie dla obrazów o tych samych wymiarach M x N i strukturze ich macierzy.
Dodawanie obrazów jest użyteczne w uśrednianiu obrazów, wykonywanym w celu zredukowania na nich szumu.
Algorytm sumowania obrazu z obrazem polega na dodaniu do wartości piksla z pierwszego obrazu, wartości odpowiadającego piksla z drugiego obrazu.
Po operacji sumowania następuje normalizacja obrazu.

\begin{enumerate}	
		\item Weź dwa identycznych rozmiarów obrazy $P1$ i $P2$
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Policz sumy odpowiadających składowych barwy.
		\item Wybierz największą sumę $Q_{max} = max(R_{s}, G_{s}, B_{s})$ i policz równania:\\
		$Q_{R}[i,j] = (R_{S} * 255)/Q_{max}$,\\
		$Q_{G}[i,j] = (G_{S} * 255)/Q_{max}$,\\
		$Q_{B}[i,j] = (B_{S} * 255)/Q_{max}$.\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sum_Img1_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sum_Img2_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sum_Img_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sum_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to barwowe obrazy wejściowe, następnie obraz powstały w wyniku sumowania obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sum_Img1_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sum_Img2_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sum_Img_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sum_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to barwowe obrazy wejściowe, następnie obraz powstały w wyniku sumowania obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}


\begin{lstlisting}[caption=Sumowanie obrazów barwowych]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
Q_max = 0
D_max = 0
X = 0
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R = int(image1_matrix[x][y][0]) + int(image2_matrix[x][y][0])
        G = int(image1_matrix[x][y][1]) + int(image2_matrix[x][y][1])
        B = int(image1_matrix[x][y][2]) + int(image2_matrix[x][y][2])
        
        # Poszukiwanie maksimum               
        if Q_max < max([R, G, B]):
            Q_max = max([R, G, B])

# Sprawdzenie czy maximum przekracza zakres
if Q_max > 255:
    D_max = Q_max - 255
    X = (D_max/255) # Obliczenie proporcji

# Obliczenie sum z uwzglednieniem zakresu
for y in range(height):
    for x in range(width): 
        R = (image1_matrix[x][y][0] - (image1_matrix[x][y][0] * X)) + (image2_matrix[x][y][0] - (image2_matrix[x][y][0] * X))
        G = (image1_matrix[x][y][1] - (image1_matrix[x][y][1] * X)) + (image2_matrix[x][y][1] - (image2_matrix[x][y][1] * X))
        B = (image1_matrix[x][y][2] - (image1_matrix[x][y][2] * X)) + (image2_matrix[x][y][2] - (image2_matrix[x][y][2] * X))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}

\section {Mnożenie obrazu przez zadaną liczbę}
\hfill\\
\indent
Mnożenie obrazu f przez skalar wykonuje się mnożąc każdy element obrazu $f_{i,j}$ (wartość funkcji obrazowej piksla) przez ten skalar. Barwa wynikowa jest zawsze barwą ciemniejszą.

\begin{enumerate}
		\item Dla wszystkich pikseli w obrazie wykonaj:
		\item Jeżli składowa barwy piksela $P_{1}[i,j]$ ma wartość 255 to składowa wynikowa otrzymuje wartość odpowiadającą wartości stalej.
		\item W przeciwnym przypadku, jeżeli składowa barwy piksla $P_{1}[i,j]$ ma wartość 0 to składowa wynikowa otrzymuje wartość 0.
		\item W przeciwnym wypadku mnóż odpowiednie składowe, a wynik dziel przez 255 zaokrąglajac do najbliższej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Const_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po przemnożeniu przez liczbę 50, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Multipl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Multipl_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Const_Multipl_Result_Norm}
	\end{center}
	\caption{(Od lewej) Szary obraz wejściowy, obraz po przemnożeniu przez liczbę 100, obraz po normalizacji }

\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Mnożenie obrazu barwowego przez zadaną liczbę]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        R = int(image_matrix[x][y][0])
        G = int(image_matrix[x][y][1])
        B = int(image_matrix[x][y][2])

        if R == 255:
            R = const
        elif R == 0:
            R = 0
        else:
            R = (int(image_matrix[x][y][0]) * int(const))/255 
        
        if G == 255:
            G = const
        elif G == 0:
            G = 0
        else:
            G = (int(image_matrix[x][y][1]) * int(const))/255 
        
        if B == 255:
            B = const
        elif B == 0:
            B = 0
        else:
            B = (int(image_matrix[x][y][2]) * int(const))/255 

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))


\end{lstlisting}

\section {Mnożenie obrazu przez inny obraz}
\hfill\\
\indent
Mnożenie obrazu f przez inny obraz wykonuje się mnożąc każdy element obrazu $P1_{i,j}$ (wartość funkcji obrazowej piksla) przez odpowiadającego piksla drugiego obrazu $P2_{i,j}$

	\begin{enumerate}
		\item Dla wszystkich pikseli w obrazie wykonaj:
		\item Jeżli składowa piksela $P_{1}[i,j]$ ma wartość 255 to składowa wynikowa otrzymuje wartość odpowiadającą wartości składowej $P_{2}[i,j]$.
		\item W przeciwnym przypadku, jeżli składowa piksela $P_{1}[i,j]$ ma wartość 0 to składowa wynikowa otrzymuje wartość 0.
		\item W przeciwnym wypadku mnóż odpowiednie składowe, a wynik dziel przez 255 zaokrąglając do najbliższej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Multipl_Img1_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Multipl_Img2_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Multipl_Img_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Multipl_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to barwowe obrazy wejściowe, następnie obraz powstały w wyniku przemnożenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Multipl_Img1_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Multipl_Img2_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Multipl_Img_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Multipl_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Pierwsze dwa to barwowe obrazy wejściowe, następnie obraz powstały w wyniku przemnożenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Mnożenie obrazu barwowego przez inny obraz ]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        if R == 255:
            R = image2_matrix[x][y][0]
        elif R == 0:
            R = 0
        else:
            R = (int(image1_matrix[x][y][0]) * int(image2_matrix[x][y][0]))/255 
        
        if G == 255:
            G = image2_matrix[x][y][1]
        elif G == 0:
            G = 0
        else:
            G = (int(image1_matrix[x][y][1]) * int(image2_matrix[x][y][1]))/255 
        
        if B == 255:
            B = image2_matrix[x][y][2]
        elif B == 0:
            B = 0
        else:
            B = (int(image1_matrix[x][y][2]) * int(image2_matrix[x][y][2]))/255 

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))


\end{lstlisting}


\section{ Mieszanie obrazów z określonym współczynnikiem}
\hfill\\
\indent
Mieszanie dwóch obrazów polega na sumowaniu ich z wagami $\alpha$ i $(1 - \alpha)$, odpowiednio, wg wzoru:
	
	\begin{center}
		$f_{m} = f\alpha + f^I(1 - \alpha)$,
	\end{center}
	gdzie $\alpha \in [0,1]$. Płynna zmiana parametru $\alpha$ w przedziale $[0,1]$ powoduje efekt przechodzenia obrazu $f^I$ w obraz $f$. W mieszaniu obrazów nie ma problemu normalizacji, a jedynie jednolitosci struktur i typów obrazowych. 
	
	\begin{enumerate}	
		\item Weź dwa identycznych rozmiarów obrazy $P_{1}$ i $P_{2}$.
		\item Okrelśl współczynnik mieszania $\alpha$ wyrażony jako liczba rzeczywista z zakresu $ < 0,1 > $; 0 reprezentuje pewną przezroczystość, 1 - nieprzezroczystości. 
		\item Dla wszystkich pikseli w obrazach wejściowych wykonuj $Q(i,j) = \alpha * P_{1}(i,j) + (1 - \alpha) * P_{2}(i,j)$
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Mix_Img1_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Mix_Img2_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Mix_Img_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Mix_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku mieszania obrazów ze współczynnikiem $\alpha$=0.5, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Mix_Img1_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Mix_Img2_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Mix_Img_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Mix_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku mieszania obrazów ze współczynnikiem $\alpha$=0.8, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{lstlisting}[caption=Mieszanie obrazów barwowych z określonym współczynnikiem]

image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0

for y in range(height):
    for x in range(width):  

        R = float(image1_matrix[x][y][0]) * alfa + (1-alfa) * float(image2_matrix[x][y][0])
        G = float(image1_matrix[x][y][1]) * alfa + (1-alfa) * float(image2_matrix[x][y][1])
        B = float(image1_matrix[x][y][2]) * alfa + (1-alfa) * float(image2_matrix[x][y][2])

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))


\end{lstlisting}

\section{ Potęgowanie obrazu}

\hfill\\
\indent

\begin{center} Potęgowanie obrazu jest szczególnym przypadkiem operacji mnożenia obrazów. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru ~\cite{WykRat}:
		$f_{m} = 255(\frac{f(x,y)}{f_{max}}) ^{\alpha}, \alpha > 0 $
	\end{center}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Pow_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Pow_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Pow_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po podniesieniu do potęgi $\alpha$=2, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Pow_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Pow_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Pow_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po podniesieniu do potęgi $\alpha$=3, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Potęgowanie obrazu barwowego]

image1_matrix = self.im1
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

for y in range(height):
    for x in range(width):  

        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        if f_img_max < max([R, G, B]):
            f_img_max = max([R, G, B])

for y in range(height):
    for x in range(width):  

        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        if R == 0:
            R = 0
        else:
            R = 255 * (math.pow(int(image1_matrix[x][y][0]) / f_img_max, alfa))

        if G == 0:
            G = 0
        else:
            G = 255 * (math.pow(int(image1_matrix[x][y][1]) / f_img_max, alfa))
        
        if B == 0:
            B = 0
        else:
            B = 255 * (math.pow(int(image1_matrix[x][y][2]) / f_img_max, alfa))

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))


\end{lstlisting}


\section{ Dzielenie obrazu przez (zadaną) liczbę}

\hfill\\
\indent

Dzielenie obrazów stosuje się w celu korekcji cieniowania między poziomami szarości.

\begin{enumerate}	
		
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Policz sumy piksli ze stałą.
		\item Wybierz największę sumę  $Q_{max} = max(R_{s}, G_{s}, B_{s})$ i policz równania:\\
		$Q_{R}[i,j] = (R_{S} * 255)/Q_{max}$,\\
		$Q_{G}[i,j] = (G_{S} * 255)/Q_{max}$,\\
		$Q_{B}[i,j] = (B_{S} * 255)/Q_{max}$.,\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po podzieleniu przez liczbę=15, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po podzieleniu przez liczbę=3, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=  Dzielenie obrazu barwowego przez (zadaną) liczbę]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image_matrix[x][y][0]) + int(const)
        G_S = int(image_matrix[x][y][1]) + int(const)
        B_S = int(image_matrix[x][y][2]) + int(const)

        # Poszukiwanie maksimum
        if Q_max < max([R_S, G_S, B_S]):
            Q_max = max([R_S, G_S, B_S])

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image_matrix[x][y][0]) + int(const)
        G_S = int(image_matrix[x][y][1]) + int(const)
        B_S = int(image_matrix[x][y][2]) + int(const)

        Q_R = (R_S * 255)/Q_max
        Q_G = (G_S * 255)/Q_max
        Q_B = (B_S * 255)/Q_max
            
        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(Q_R)
        result_matrix[x][y][1] = math.ceil(Q_G)
        result_matrix[x][y][2] = math.ceil(Q_B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([Q_R, Q_G, Q_B]):
            f_min = min([Q_R, Q_G, Q_B])
        if f_max < max([Q_R, Q_G, Q_B]):
            f_max = max([Q_R, Q_G, Q_B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}

\section{ Dzielenie obrazu przez inny obraz }

\hfill
\\\\
\indent

\begin{enumerate}	
		
		\item Dla wszystkich pikseli w tych obrazach wykonaj:
		\item Weź dwa identycznych rozmiarów obrazy $P1$ i $P2$
		\item Policz sumy piksli ze stałą.
		\item Wybierz największę sumę  $Q_{max} = max(R_{s}, G_{s}, B_{s})$ i policz równania:\\
		$Q_{R}[i,j] = (R_{S} * 255)/Q_{max}$\\
		$Q_{G}[i,j] = (G_{S} * 255)/Q_{max}$\\
		$Q_{B}[i,j] = (B_{S} * 255)/Q_{max}$\\
		Wynik zaokrąglij do najbliższej górnej liczby całkowitej.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Img1_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Img2_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Img_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Div_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku dzielenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Img1_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Img2_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Img_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Div_Img_Result_Norm}
	\end{center}
	\caption{(Od lewej) Dwa obrazy wejściowe, następnie obraz powstały w wyniku dzielenia obrazów, poniżej obraz wynikowy po normalizacji }
\end{figure}

\begin{lstlisting}[caption= Dzielenie obrazu barwowego przez inny obraz]


image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image1_matrix[x][y][0]) + int(image2_matrix[x][y][0])
        G_S = int(image1_matrix[x][y][1]) + int(image2_matrix[x][y][1])
        B_S = int(image1_matrix[x][y][2]) + int(image2_matrix[x][y][2])

        # Poszukiwanie maksimum
        if Q_max < max([R_S, G_S, B_S]):
            Q_max = max([R_S, G_S, B_S])

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image1_matrix[x][y][0]) + int(image2_matrix[x][y][0])
        G_S = int(image1_matrix[x][y][1]) + int(image2_matrix[x][y][1])
        B_S = int(image1_matrix[x][y][2]) + int(image2_matrix[x][y][2])

        Q_R = (R_S * 255)/Q_max
        Q_G = (G_S * 255)/Q_max
        Q_B = (B_S * 255)/Q_max

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(Q_R)
        result_matrix[x][y][1] = math.ceil(Q_G)
        result_matrix[x][y][2] = math.ceil(Q_B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([Q_R, Q_G, Q_B]):
            f_min = min([Q_R, Q_G, Q_B])
        if f_max < max([Q_R, Q_G, Q_B]):
            f_max = max([Q_R, Q_G, Q_B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}


\section{ Pierwiastkowanie obrazu}

\hfill
\\\\
\indent

\begin{center} Pierwiastkowanie obrazu jest szczególnym przypadkiem operacji potęgowania obrazów, gdzie wykładnikiem jest ułamek. Aby uniknąć wykroczenia poza zakres, skorzystano ze znormalizowanego wzoru ~\cite{WykRat}:

		$f_{m} = 255(\frac{f(x,y)}{f_{max}}) ^{\alpha}, \alpha > 0 $
	\end{center}
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sqrt_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sqrt_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Sqrt_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po spierwiastkowaniu pierwiastkiem kwadratowym ($\alpha$=1/2), obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sqrt_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sqrt_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Sqrt_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po spierwiastkowaniu pierwiastkiem stopnia trzeciego ($\alpha$=1/3), obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Pierwiastkowanie obrazu barwowego]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
Q_max = 0

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image_matrix[x][y][0]) + int(const)
        G_S = int(image_matrix[x][y][1]) + int(const)
        B_S = int(image_matrix[x][y][2]) + int(const)

        # Poszukiwanie maksimum
        if Q_max < max([R_S, G_S, B_S]):
            Q_max = max([R_S, G_S, B_S])

for y in range(height):
    for x in range(width):  

        # Obliczanie sum
        R_S = int(image_matrix[x][y][0]) + int(const)
        G_S = int(image_matrix[x][y][1]) + int(const)
        B_S = int(image_matrix[x][y][2]) + int(const)

        Q_R = (R_S * 255)/Q_max
        Q_G = (G_S * 255)/Q_max
        Q_B = (B_S * 255)/Q_max
            
        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(Q_R)
        result_matrix[x][y][1] = math.ceil(Q_G)
        result_matrix[x][y][2] = math.ceil(Q_B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([Q_R, Q_G, Q_B]):
            f_min = min([Q_R, Q_G, Q_B])
        if f_max < max([Q_R, Q_G, Q_B]):
            f_max = max([Q_R, Q_G, Q_B])

# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}


\section{ Logarytmowanie obrazu}

\hfill\\
\indent
Logarytmowanie obrazu powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu.
Wykorzystano wzór z normalizacją ~/cite{WykRat}:
	
	\begin{center}
		$f_{m} = 255(frac{log(1 + f(x,y))}{log(1 + f_{max})})$
	\end{center}

	
Przesunięcie funkcji obrazowej $f$ do góry o 1 przed jej logarytmowaniem wynika z nieokreśloności logarytmu w zerze. Logarytmowanie obrazu powoduje rozjaśnienie i zróżnicowanie najciemniejszych obszarów obrazu.	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Color_Log_Original}
		\includegraphics[width=0.3\textwidth]{1/1Color_Log_Result}
		\includegraphics[width=0.3\textwidth]{1/1Color_Log_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Color_Log_Original}
		\includegraphics[width=0.3\textwidth]{2/2Color_Log_Result}
		\includegraphics[width=0.3\textwidth]{2/2Color_Log_Result_Norm}
	\end{center}
	\caption{(Od lewej) Barwowy obraz wejściowy, obraz po logarytmowaniu logarytmem naturalnym, obraz po normalizacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Logarytmowanie obrazu barwowego]


image1_matrix = self.im1
image2_matrix = self.im2
height = image1_matrix.shape[0]   # wysokosc
width = image1_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((width, height, 3), dtype=np.uint8)

# Inicjalizacja zmiennych
f_min = 255
f_max = 0
f_img_max = 0

for y in range(height):
    for x in range(width):  
        
        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        # Poszukiwanie maksimum                
        if f_img_max < max([R, G, B]):
            f_img_max = max([R, G, B])

for y in range(height):
    for x in range(width):  
        
        R = int(image1_matrix[x][y][0])
        G = int(image1_matrix[x][y][1])
        B = int(image1_matrix[x][y][2])

        if R == 0:
            R = 0
        else:
            R = math.log(1 + int(image1_matrix[x][y][0])) / math.log(1 + int(f_img_max)) * 255

        if G == 0:
            G = 0
        else:
            G = math.log(1 + int(image1_matrix[x][y][1])) / math.log(1 + int(f_img_max)) * 255
        
        if B == 0:
            B = 0
        else:
            B = math.log(1 + int(image1_matrix[x][y][2])) / math.log(1 + int(f_img_max)) * 255

        # Zaokroglenie do najblizszej wartosci calkowitej z gory
        # i przypisanie wartosci
        result_matrix[x][y][0] = math.ceil(R)
        result_matrix[x][y][1] = math.ceil(G)
        result_matrix[x][y][2] = math.ceil(B)

        # Poszukiwanie minimum i maksimum                
        if f_min > min([R, G, B]):
            f_min = min([R, G, B])
        if f_max < max([R, G, B]):
            f_max = max([R, G, B])


# Normalizacja
norm_matrix = np.zeros((width, height, 3), dtype=np.uint8)
for y in range(height):
    for x in range(width):
        norm_matrix[x][y][0] = 255 * ((result_matrix[x][y][0] - f_min) / (f_max - f_min))
        norm_matrix[x][y][1] = 255 * ((result_matrix[x][y][1] - f_min) / (f_max - f_min))
        norm_matrix[x][y][2] = 255 * ((result_matrix[x][y][2] - f_min) / (f_max - f_min))

\end{lstlisting}


\chapter{Operacje geometryczne na obrazie}
\hfill\\
\indent
Transformacje geometryczne są szczególnie wykorzystywane w przypadku dopasowywania obrazu do układu współrzędnych oraz w przypadku eliminowania zniekształceń geometrycznych obrazu. W przedstawionych operacjach obrazy umieszczane są w pierwszej ćwiartce układu współrzędnych.

\section{ Przemieszczenie obrazu o zadany wektor}
\hfill\\
\indent

Przesuwanie obrazu polega na zmianie współrzędnych każdego piksela obrazu o określoną wartość zgodnie z zależnościami:
	
	\begin{center}
		$x^I = x_{o} + \Delta x$\\
		$y^I = y_{o} + \Delta y$
	\end{center}
	
	gdzie $(x_{o},y_{o})$ - współrzędnych początkowe piksla; ($\Delta{x},\Delta{y}$) - wartości przesunięcia; $(x^I,y^I)$ - współrzędne piksla po przesunięciu;

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Move_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Move_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz po przesunięciu o wektor [40, 70] }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Move_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Move_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz po przesunięciu o wektor [200, 100] }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Przemieszczenie obrazu o zadany wektor]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

delta_y = 0 - delta_y # Poruszamy sie w pierwszej cwartce ukladu wspolrzednych

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

for y in range(height):
    for x in range(width):  
        if 0 < y+delta_y < height and 0 < x+delta_x < width:
            result_matrix[y+delta_y][x+delta_x] = image_matrix[y][x]

\end{lstlisting}

\section{ Jednorodne skalowanie obrazu}
\hfill\\
\indent
Skalowanie jednorodne obrazu polega na pomnożeniu współrzędnych każdego piksla obrazu przez współczynnik skalowania $S$ wg. wzoru:
	
	\begin{center}
		$x^I = x_{o} * S$ \\
		$y^I = y_{o} * S$
	\end{center}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleJ_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleJ_Result}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleJ_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz skalowaniu jednorodnym ze współczynnikiem S=1.5 , obraz po interpolacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleJ_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleJ_Result}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleJ_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz skalowaniu jednorodnym ze współczynnikiem S=2, obraz po interpolacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Jednorodne skalowanie obrazu]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

# result_matrix = np.empty((math.ceil(height/scale_y), math.ceil(width/scale_x), 3), dtype=np.uint8)
result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

for y in range(height):
    for x in range(width): 
        if scale*y < height and scale*x < width:
            # result_matrix[y][x] = image_matrix[scale*y][scale*x]
            result_matrix[int(scale*y)][int(scale*x)] = image_matrix[y][x]

resultImage2 = np.copy(result_matrix)
tmp = np.ones((height, width, 3), dtype = np.uint8)

# Interpolacja
for i in range(height):
    for j in range(width):
        r, g, b = 0, 0, 0
        n = 1
        tmp[i, j] = resultImage2[i, j]
        if (resultImage2[i, j][0] < 1) & (resultImage2[i, j][1] < 1) & (resultImage2[i, j][2] < 1):
            for iOff in range(-1, 2):
                for jOff in range(-1, 2):
                    iSafe = i if ((i + iOff) > (height - 2)) | ((i + iOff) < 0) else (i + iOff)
                    jSafe = j if ((j + jOff) > (width - 2)) | ((j + jOff) < 0) else (j + jOff)
                    if (resultImage2[iSafe, jSafe][0] > 0) | (resultImage2[iSafe, jSafe][1] > 0) | (resultImage2[iSafe, jSafe][2] > 0):
                        r += resultImage2[iSafe, jSafe][0]
                        g += resultImage2[iSafe, jSafe][1]
                        b += resultImage2[iSafe, jSafe][2]
                        n += 1
            tmp[i, j] = (r/n, g/n, b/n)
            resultImage2[i, j] = tmp[i, j]

\end{lstlisting}

\section{ Niejednorodne skalowanie obrazu}
\hfill\\
\indent
Skalowanie niejednorodne obrazu polega na pomnożeniu współrzędnych każdego piksla obrazu przez współczynniki skalowania $S_{x}, S_{y}$ wg. wzoru:

\begin{center}
	$x^I = x_{o} * S_{x}$ \\
	$y^I = y_{o} * S_{y}$
\end{center}

gdzie $(x_{o},y_{o})$ - współrzędne początkowe piksela; ($S_{x}, S_{y}$) - wartości współczynników skalowania; $(x^I,y^I)$ - współrzędne piksla po skalowaniu;

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleNJ_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleNJ_Result}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ScaleNJ_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz skalowaniu niejednorodnym ze współczynnikiem $S_{x}$=2 oraz współczynnikiem $S_{y}$=1 , obraz po interpolacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleNJ_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleNJ_Result}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ScaleNJ_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz skalowaniu niejednorodnym ze współczynnikiem $S_{x}$=1 oraz współczynnikiem $S_{y}$=2 , obraz po interpolacji }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Niejednorodne skalowanie obrazu]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

# result_matrix = np.empty((math.ceil(height/scale_y), math.ceil(width/scale_x), 3), dtype=np.uint8)
result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

for y in range(height):
    for x in range(width): 
        if scale_y*y < height and scale_x*x < width:
            # result_matrix[y][x] = image_matrix[scale_y*y][scale_x*x]
            result_matrix[int(scale_y*y)][int(scale_x*x)] = image_matrix[y][x]

resultImage2 = np.copy(result_matrix)
tmp = np.ones((height, width, 3), dtype = np.uint8)

# Interpolacja
for i in range(height):
    for j in range(width):
        r, g, b = 0, 0, 0
        n = 1
        tmp[i, j] = resultImage2[i, j]
        if (resultImage2[i, j][0] < 1) & (resultImage2[i, j][1] < 1) & (resultImage2[i, j][2] < 1):
            for iOff in range(-1, 2):
                for jOff in range(-1, 2):
                    iSafe = i if ((i + iOff) > (height - 2)) | ((i + iOff) < 0) else (i + iOff)
                    jSafe = j if ((j + jOff) > (width - 2)) | ((j + jOff) < 0) else (j + jOff)
                    if (resultImage2[iSafe, jSafe][0] > 0) | (resultImage2[iSafe, jSafe][1] > 0) | (resultImage2[iSafe, jSafe][2] > 0):
                        r += resultImage2[iSafe, jSafe][0]
                        g += resultImage2[iSafe, jSafe][1]
                        b += resultImage2[iSafe, jSafe][2]
                        n += 1
            tmp[i, j] = (r/n, g/n, b/n)
            resultImage2[i, j] = tmp[i, j]

\end{lstlisting}


\section{ Obracanie obrazu o dowolny kąt}
\hfill\\
\indent

Operację obrotu dookoła początku układu współrzędnych wykonuje się zgodnie ze wzorem:
	
	\begin{center}
		$x^I = x_{o} * cos\alpha - y_{o} * sin\alpha$\\
		$y^I = x_{o} * sin\alpha + y_{o} * cos\alpha$
	\end{center}
	
	gdzie $(x_{o},y_{o})$ - współrzędne początkowe piksla; $\alpha$ - kąt obrotu; $(x^I,y^I)$ - współrzędne piksela po obrocie;

W przedstawionych przykładach punkt obrotu został przesunięty na środek obrazu według wzoru:

	\begin{center}
        $new_x = (x - width/2) * math.cos(alfa_r) - (y - height/2) * math.sin(alfa_r) + (width/2)$\\
        $new_y = (x - width/2) * math.sin(alfa_r) + (y - height/2) * math.cos(alfa_r) + (height/2)$\\
	\end{center}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Turn_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Turn_Result}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Turn_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz po obróceniu wokół  środka obrazu o kąt 40 stopni, obraz po interpolacji }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Turn_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Turn_Result}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Turn_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz po obróceniu wokół  środka obrazu o kąt 110 stopni, obraz po interpolacji }
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption=Obracanie obrazu o dowolny kąt]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

# Przeksztalcenie na radiany
alfa_r = math.radians(alfa)

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)


for y in range(height):
    for x in range(width): 
        new_x = (x - width/2) * math.cos(alfa_r) - (y - height/2) * math.sin(alfa_r) + (width/2)
        new_y = (x - width/2) * math.sin(alfa_r) + (y - height/2) * math.cos(alfa_r) + (height/2)
        if new_y < height and new_y >= 0 and new_x >= 0 and new_x < width:
            result_matrix[int(new_y)][int(new_x)] = image_matrix[y][x]

resultImage2 = np.copy(result_matrix)
tmp = np.ones((height, width, 3), dtype = np.uint8)

# Interpolacja
for i in range(height):
    for j in range(width):
        r, g, b = 0, 0, 0
        n = 1
        tmp[i, j] = resultImage2[i, j]
        if (resultImage2[i, j][0] < 1) & (resultImage2[i, j][1] < 1) & (resultImage2[i, j][2] < 1):
            for iOff in range(-1, 2):
                for jOff in range(-1, 2):
                    iSafe = i if ((i + iOff) > (height - 2)) | ((i + iOff) < 0) else (i + iOff)
                    jSafe = j if ((j + jOff) > (width - 2)) | ((j + jOff) < 0) else (j + jOff)
                    if (resultImage2[iSafe, jSafe][0] > 0) | (resultImage2[iSafe, jSafe][1] > 0) | (resultImage2[iSafe, jSafe][2] > 0):
                        r += resultImage2[iSafe, jSafe][0]
                        g += resultImage2[iSafe, jSafe][1]
                        b += resultImage2[iSafe, jSafe][2]
                        n += 1
            tmp[i, j] = (r/n, g/n, b/n)
            resultImage2[i, j] = tmp[i, j]


\end{lstlisting}
\newpage

\section{ Symetrie względem osi układu}

\subsection*{ Symetria względem osi X}
\hfill\\
\indent
Względem osi OX pikslem symetrycznym do piksla $P_{1}(x,y)$ jest piksel $P_{2}(x,-y)$
	

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ox_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_ox_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem osi X }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ox_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_ox_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem osi X }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Symetrie względem osi X]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)
_height = height-1 #array height last index

for y in range(height):
    for x in range(width): 
            result_matrix[y][x] = image_matrix[_height-y][x]

\end{lstlisting}

\subsection*{ Symetria względem osi Y}
\hfill\\
\indent
Względem osi OY pikslem symetrycznym do piksla $P_{1}(x,y)$ jest piksel $P_{2}(-x,y)$


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_oy_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_oy_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem osi Y }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_oy_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_oy_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem osi Y }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Symetrie względem osi Y]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)
_width = width - 1 #array width last index

for y in range(height):
    for x in range(width): 
            result_matrix[y][x] = image_matrix[y][_width - x]

\end{lstlisting}

\section{ Symetrie względem zadanej prostej}
\hfill\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_px_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_px_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem pionowej prostej poprowadzonej przez środek obrazu }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_px_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_px_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem pionowej prostej poprowadzonej przez środek obrazu }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_py_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_py_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem poziomej prostej poprowadzonej przez środek obrazu }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_py_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_py_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy, obraz symetryczny względem poziomej prostej poprowadzonej przez środek obrazu }
\end{figure}

\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Symetrie względem zadanej prostej]


image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

#Symetria wzgledem poziomej prostej poprowadzonej przez srodek obrazu
result_matrix = np.zeros((height, width, 3), dtype=np.uint8)
_height = height - 1 #array height last index

param_y = height/2

for y in range(height):
    for x in range(width): 
        if y < param_y:
            result_matrix[y][x] = image_matrix[y][x]
        else:
            result_matrix[y][x] = image_matrix[_height - y][x]

#Symetria wzgledem pionowej prostej poprowadzonej przez srodek obrazu
result_matrix = np.zeros((height, width, 3), dtype=np.uint8)
_width = width - 1 #array width last index

param_x = width/2

for y in range(height):
    for x in range(width): 
        if x < param_x:
            result_matrix[y][x] = image_matrix[y][x]
        else:
            result_matrix[y][x] = image_matrix[y][_width - x]

\end{lstlisting}



\section{ Wycinanie fragmentów obrazu}
\hfill\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Cut_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Cut_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz po wycięciu fragmentu o współrzędnych $x_{min}=100, x_{max}=250, y_{min}=25, y_{max}=450$ }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Cut_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Cut_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz po wycięciu fragmentu o współrzędnych $x_{min}=200, x_{max}=400, y_{min}=200, y_{max}=400$ }
\end{figure}


\subsection*{Kod źródłowy}


\begin{lstlisting}[caption= Wycinanie fragmentów obrazu]

image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

for y in range(height):
    for x in range(width): 
        # Poruszamy sie w pierwszej cwiartce osi ukladu wspolrzednych
        if x > x_min and x < x_max and y < height-y_min and y > height-y_max:
            result_matrix[y][x] = 0
        else:
            result_matrix[y][x] = image_matrix[y][x]

\end{lstlisting}

\section{ Kopiowanie fragmentów obrazów}
\hfill\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Copy_Original}
		\includegraphics[width=0.3\textwidth]{1/1Geo_Copy_Result}
		\includegraphics[height=4cm]{1/1Geo_Copy_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz (512x512) ze skopiowanym fragmentem o współrzędnych $x_{min}=100, x_{max}=250, y_{min}=25, y_{max}=450$, Skopiowany fragment (151x426) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Copy_Original}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Copy_Result}
		\includegraphics[width=0.3\textwidth]{2/2Geo_Copy_Result_Interp}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz (512x512) ze skopiowanym fragmentem o współrzędnych $x_{min}=200, x_{max}=400, y_{min}=200, y_{max}=400$, Skopiowany fragment (201x201) }
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Kopiowanie fragmentów obrazów]


image_matrix = self.im1
height = image_matrix.shape[0]   # wysokosc
width = image_matrix.shape[1]    # szereoksc

result_matrix = np.zeros((height, width, 3), dtype=np.uint8)

# Macierz o wymiarach wycinanego fragmentu
cut_matrix = np.zeros((y_max-y_min + 1, x_max-x_min + 1, 3), dtype=np.uint8)

cut_y = 0
for y in range(height):
    cut_x = 0
    for x in range(width): 
        # Poruszamy sie w pierwszej cwiartce osi ukladu wspolrzednych
        if x >= x_min and x <= x_max and y <= height-y_min and y >= height-y_max:    
            result_matrix[y][x] = image_matrix[y][x]
            cut_matrix[cut_y][cut_x] = image_matrix[y][x]
            cut_x+=1
    if cut_x > 0:    
        cut_y+=1

\end{lstlisting}



\chapter{Operacje na histogramie obrazu szarego}
1. obliczanie histogramu
2. przemieszczanie histogramu
3. rozciąganie histogramu
4. progowanie lokalne
5. progowanie globalne

\chapter{Operacje na histogramie obrazu barwowego}
1. obliczanie histogramu
2. przemieszczanie histogramu
3. rozciąganie histogramu
4. progowanie 1-progowe
5. progowanie wieloprogowe
6. progowanie lokalne
7. progowanie globalne

\chapter{Operacje morfologiczne na obrazach binarnych}

W obrazie binarnym piksele mogą przybierać tylko dwie wartości. Zazwyczaj kodowane są za pomocą pojedynczego bitu i przyjmują wartość 0 lub 1. Spotyka się także reprezentacje wykorzystujące inne pary wartości: (0, 255), (-1, 1), (True, False). \\
W przedstawionych przykładach została użyta reprezentacja (0,255), gdzie 0 oznacza czerń a 255 biały.

W przetwarzaniu obrazów binarnych ważne jest określenie, kiedy dwa piksele sąsiadują ze sobą. W tym celu definiuje się dla każdego piksla jego sąsiedztwo. Przy implementacji wykorzystano sąsiedztwo czterospójne: 

	Sąsiedztwo czterospójne (von Neumanna) - obejmuje cztery piksele przyległe do danego z góry, dołu i po bokach
	\begin{center}
	 $N_{4}(p)=((x,y-1),(x,y+1),(x-1,y),(x+1,y))$
	 \end{center}

\section{ Okrawanie (erozja)}
\hfill\\
\indent
       Przyjeto, ze wartosci wykraczajace poza granice (wysokość/szerokość) obrazu są białe (maja wartość 255)
	\begin{enumerate}	
		\item Dla wszystkich pikseli wykonaj:
		\item Wczytaj wartości sąsiadujących pikseli $(x,y-1),(x,y+1),(x-1,y),(x+1,y)$ od piksla $(x,y)$.
		\item Jeżeli którykolwiek z sąsiadów ma wartość równą 255 to środkowy piksel $(x,y)$ ma przyjąć wartość 255. 
		\item Jeżeli wszyscy sąsiedzi mają wartość równą 0 to środkowy piksel $(x,y)$ ma przyjąć wartość 0.
	\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Bin_E_Original}
		\includegraphics[width=0.3\textwidth]{1/1Bin_E_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po operacji okrawania (erozji) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Bin_E_Original}
		\includegraphics[width=0.3\textwidth]{2/2Bin_E_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po operacji okrawania (erozji) }
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja okrawania (erozji) na obrazie binarnym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((height, width), dtype=np.uint8)

for y in range(height):
    for x in range(width):  
        # Przyjeto, ze wartosci wykraczajace poza granice obrazu sa biale (maja wartosc 255)
        neighbour_pix = [255, 255, 255, 255]

        if x - 1 > 0:
                neighbour_pix[0]=(image_matrix[y][x-1][0])
        if y - 1 > 0:
                neighbour_pix[1]=(image_matrix[y-1][x][0])
        if x + 1 < width:
                neighbour_pix[2]=(image_matrix[y][x+1][0])
        if y + 1 < height:
                neighbour_pix[3]=(image_matrix[y+1][x][0])

        if 255 in neighbour_pix:
                result_matrix[y][x] = 255 #bialy
        else:
                result_matrix[y][x] = 0 #czarny   

\end{lstlisting}

\section{ Nakładanie (dylatacja)}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Bin_D_Original}
		\includegraphics[width=0.3\textwidth]{1/1Bin_D_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po operacji nakładania (dylatacji) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Bin_D_Original}
		\includegraphics[width=0.3\textwidth]{2/2Bin_D_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po operacji nakładania (dylatacji)}
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja nakładania (dylatacji) na obrazie binarnym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((height, width), dtype=np.uint8)

for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(image_matrix[y][x-1][0])
                if y - 1 > 0:
                        neighbour_pix[1]=(image_matrix[y-1][x][0])
                if x + 1 < width:
                        neighbour_pix[2]=(image_matrix[y][x+1][0])
                if y + 1 < height:
                        neighbour_pix[3]=(image_matrix[y+1][x][0])

                if 0 in neighbour_pix:
                        result_matrix[y][x] = 0
                else:
                        result_matrix[y][x] = 255          

\end{lstlisting}

\section{ Otwarcie}
.
\hfill
\\\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Op_Original}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Op_E_Result}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Op_ED_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po dylacji, obraz po operacji otwarcia (erozja $\rightarrow$ dylatacja)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Op_Original}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Op_E_Result}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Op_ED_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po dylacji, obraz po operacji otwarcia (erozja $\rightarrow$ dylatacja)}
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja otwarcia na obrazie binarnym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

e_result_matrix = np.zeros((height, width), dtype=np.uint8)
d_result_matrix = np.zeros((height, width), dtype=np.uint8)

#erozja
for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(image_matrix[y][x-1][0])
                if y - 1 > 0:
                        neighbour_pix[1]=(image_matrix[y-1][x][0])
                if x + 1 < width:
                        neighbour_pix[2]=(image_matrix[y][x+1][0])
                if y + 1 < height:
                        neighbour_pix[3]=(image_matrix[y+1][x][0])

                if 255 in neighbour_pix:
                        e_result_matrix[y][x] = 255
                else:
                        e_result_matrix[y][x] = 0 

Image.fromarray(e_result_matrix).show()
#dylatacja
for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(e_result_matrix[y][x-1])
                if y - 1 > 0:
                        neighbour_pix[1]=(e_result_matrix[y-1][x])
                if x + 1 < width:
                        neighbour_pix[2]=(e_result_matrix[y][x+1])
                if y + 1 < height:
                        neighbour_pix[3]=(e_result_matrix[y+1][x])

                if 0 in neighbour_pix:
                        d_result_matrix[y][x] = 0
                else:
                        d_result_matrix[y][x] = 255   

\end{lstlisting}

\section{ Zamknięcie}
.
\hfill
\\\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Cl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Cl_D_Result}
		\includegraphics[width=0.3\textwidth]{1/1Bin_Cl_DE_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po erozji, obraz po operacji zamknięcia (dylatacja $\rightarrow$ erozja)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Cl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Cl_D_Result}
		\includegraphics[width=0.3\textwidth]{2/2Bin_Cl_DE_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (50x50), obraz po erozji, obraz po operacji zamknięcia (dylatacja $\rightarrow$ erozja)}
\end{figure}


\subsection*{Kod źródłowy}
.

\begin{lstlisting}[caption= Operacja zamknięcia na obrazie binarnym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

e_result_matrix = np.zeros((height, width), dtype=np.uint8)
d_result_matrix = np.zeros((height, width), dtype=np.uint8)

#dylatacja
for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(image_matrix[y][x-1][0])
                if y - 1 > 0:
                        neighbour_pix[1]=(image_matrix[y-1][x][0])
                if x + 1 < width:
                        neighbour_pix[2]=(image_matrix[y][x+1][0])
                if y + 1 < height:
                        neighbour_pix[3]=(image_matrix[y+1][x][0])

                if 0 in neighbour_pix:
                        d_result_matrix[y][x] = 0
                else:
                        d_result_matrix[y][x] = 255

Image.fromarray(e_result_matrix).show()

#erozja
for y in range(height):
        for x in range(width):  
                neighbour_pix = [255, 255, 255, 255]

                if x - 1 > 0:
                        neighbour_pix[0]=(d_result_matrix[y][x-1])
                if y - 1 > 0:
                        neighbour_pix[1]=(d_result_matrix[y-1][x])
                if x + 1 < width:
                        neighbour_pix[2]=(d_result_matrix[y][x+1])
                if y + 1 < height:
                        neighbour_pix[3]=(d_result_matrix[y+1][x])

                if 255 in neighbour_pix:
                        e_result_matrix[y][x] = 255
                else:
                        e_result_matrix[y][x] = 0         

\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%SZARE

\chapter {Operacje morfologiczne na obrazach szarych}

\section{ Okrawanie (erozja)}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_E_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_E_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (256x256), obraz (256x256) po operacji okrawania (erozji) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_E_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_E_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz (512x512) po operacji okrawania (erozji) }
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja okrawania (erozji) na obrazie szarym]

def erozion(self, show = False, save = False):

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((height, width), dtype=np.uint8)

for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(image_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(image_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(image_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(image_matrix[y+1][x])

            min_pix = min(neighbour_pix)
            result_matrix[y][x] = min_pix

\end{lstlisting}

\section{ Nakładanie (dylatacja)}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_D_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_D_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (256x256), obraz (256x256) po operacji nakładania (dylatacji) }
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_D_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_D_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz (512x512) po operacji nakładania (dylatacji)}
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja nakładania (dylatacji) na obrazie szarym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

result_matrix = np.zeros((height, width), dtype=np.uint8)
print(image_matrix)
print(result_matrix)

for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(image_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(image_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(image_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(image_matrix[y+1][x])

            max_pix = max(neighbour_pix)
            result_matrix[y][x] = max_pix      


\end{lstlisting}

\section{ Otwarcie}
.
\hfill
\\\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Op_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Op_E_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Op_ED_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (256x256), obraz po dylacji, obraz po operacji otwarcia (erozja $\rightarrow$ dylatacja)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Op_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Op_E_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Op_ED_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz po dylacji, obraz po operacji otwarcia (erozja $\rightarrow$ dylatacja)}
\end{figure}


\subsection*{Kod źródłowy}

\begin{lstlisting}[caption= Operacja otwarcia na obrazie szarym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

e_result_matrix = np.zeros((height, width), dtype=np.uint8)
d_result_matrix = np.zeros((height, width), dtype=np.uint8)

#erozja
for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(image_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(image_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(image_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(image_matrix[y+1][x])

            min_pix = min(neighbour_pix)
            e_result_matrix[y][x] = min_pix

Image.fromarray(e_result_matrix).show()
#dylatacja
for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(e_result_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(e_result_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(e_result_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(e_result_matrix[y+1][x])

            max_pix = max(neighbour_pix)
            d_result_matrix[y][x] = max_pix    

\end{lstlisting}

\section{ Zamknięcie}
.
\hfill
\\\\
\indent

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Cl_Original}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Cl_D_Result}
		\includegraphics[width=0.3\textwidth]{1/1Gray_Cl_DE_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (256x256), obraz po erozji, obraz po operacji zamknięcia (dylatacja $\rightarrow$ erozja)}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Cl_Original}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Cl_D_Result}
		\includegraphics[width=0.3\textwidth]{2/2Gray_Cl_DE_Result}
	\end{center}
	\caption{(Od lewej) Obraz wejściowy (512x512), obraz po erozji, obraz  po operacji zamknięcia (dylatacja $\rightarrow$ erozja)}
\end{figure}


\subsection*{Kod źródłowy}
.

\begin{lstlisting}[caption= Operacja zamknięcia na obrazie szarym]

image_matrix = self.im1
width = image_matrix.shape[1]    # szereoksc
height = image_matrix.shape[0]   # wysokosc

e_result_matrix = np.zeros((height, width), dtype=np.uint8)
d_result_matrix = np.zeros((height, width), dtype=np.uint8)

#dylatacja
for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(image_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(image_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(image_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(image_matrix[y+1][x])

            max_pix = max(neighbour_pix)
            d_result_matrix[y][x] = max_pix   


#erozja
for y in range(height):
    for x in range(width):  
            neighbour_pix = [255, 255, 255, 255]

            if x - 1 > 0:
                    neighbour_pix[0]=(d_result_matrix[y][x-1])
            if y - 1 > 0:
                    neighbour_pix[1]=(d_result_matrix[y-1][x])
            if x + 1 < width:
                    neighbour_pix[2]=(d_result_matrix[y][x+1])
            if y + 1 < height:
                    neighbour_pix[3]=(d_result_matrix[y+1][x])

            min_pix = min(neighbour_pix)
            e_result_matrix[y][x] = min_pix     

\end{lstlisting}



1. okrawanie(erozja)
2. nakładanie (dylatacja)
3. otwarcie
4. zamknięcie

\chapter {Filtrowanie liniowe i nieliniowe}
1. dolnoprzepustowe (dwa do wyboru)
2. górnoprzepustowe (Robertsa, Prewitta, Sobela, ....)
3. gradientowe (kompasowe, płaskorzeźbowe kierunkowe, gradientu wektorowego VGO, gradientu
wektora kierunkowego VDG).
4. medianowe
5. ekstremalne

\chapter{Podsumowanie}

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\bibliographystyle{plain}
\bibliography{literatura}

\end{document} 